package com.BrupExtensionProject.burp_extension;

import burp.IBurpExtenderCallbacks;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

import javax.swing.*;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import java.awt.*;
import java.awt.event.ActionEvent;
import java.io.File;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class UIComponents {
    private IBurpExtenderCallbacks callbacks;
    private ScreenshotUtility screenshotUtility;
    private VulnerabilityManager vulnerabilityManager;
    private JPanel mainPanel;
    private JPanel xChartDashboardPanel;
    private JLabel saveFolderTableDataPathLabel;
    private JLabel saveScreenshotFolderPathLabel;
    private JLabel apiStatusLabel;
    private JLabel apiStatusIcon;
    private DefaultListModel<KeywordSetting> keywordListModel;
    private JList<String> scanResultsList;
    private JTextArea scanResultTextArea;
    private JCheckBox maximizeWindowCheckbox;
    private JCheckBox enableScreenshotNumberingCheckbox;
    private JCheckBox enableAspectRatioCheckbox;
    private JCheckBox enableScreenshotCroppingCheckbox;
    private JTextField aspectRatioWidthField;
    private JTextField aspectRatioHeightField;
    private JCheckBox includeFullScreenshotCheckbox;
    private JCheckBox promptForFilenameCheckbox; // Add this to the class fields
    private JPanel hostPanel;
    
    private static final String SEARCH_ONLY_FULL_SCREENSHOTS_KEY = "searchOnlyFullScreenshots";
    private static final String KEYWORD_SETTINGS_KEY = "keywordSettings";
    private static final String SAVE_FOLDER_PATH_KEY = "saveFolderPath";
    private static final String SAVE_SCREENSHOT_FOLDER_PATH_KEY = "saveScreenshotFolderPath";
    private static final String INCLUDE_FULL_SCREENSHOT_KEY = "includeFullScreenshot";

    public UIComponents(IBurpExtenderCallbacks callbacks) {
        this.callbacks = callbacks;
        this.screenshotUtility = new ScreenshotUtility(callbacks);
        this.vulnerabilityManager = new VulnerabilityManager(callbacks, this);
        this.keywordListModel = new DefaultListModel<>();

        // Ustawienie callbacków dla CipherSuiteInfo i SSLyzeScan
        CipherSuiteInfo.setCallbacks(callbacks);
        SSLyzeScan.setCallbacks(callbacks);
    }

    public void initializeComponents() {
        mainPanel = new JPanel(new BorderLayout());
        JScrollPane vulnerabilitiesPanel = vulnerabilityManager.createScrollPane();
        JPanel screenshotTab = new JPanel();
        xChartDashboardPanel = new JPanel(new BorderLayout());
        JPanel tlsCheckerPanel = createTLSCheckerPanel();
        JPanel settingsPanel = createSettingsPanel();
        JPanel searcherPanel = createSearcherPanel(); // Dodane
        JPanel aboutPanel = createAboutPanel(); // Dodane

        JTabbedPane mainTabs = new JTabbedPane();
        mainTabs.addTab("List of vulnerabilities", vulnerabilitiesPanel);
        mainTabs.addTab("Vulnerabilities analytics", xChartDashboardPanel);
        mainTabs.addTab("TLS/SSL configuration scanner", tlsCheckerPanel);
        mainTabs.addTab("Searcher", searcherPanel); // Dodane
        mainTabs.addTab("Settings", settingsPanel);
        mainTabs.addTab("About", aboutPanel); // Dodane

        mainPanel.add(mainTabs, BorderLayout.CENTER);
        loadScanResults(); // Załaduj wyniki skanowania podczas inicjalizacji
        loadLastScannedHost(); // Załaduj ostatnio skanowany host
        updateXChartDashboard();
        loadVulnerabilities();
        loadKeywordSettings();
        loadSettings(); // Wczytaj ustawienia po inicjalizacji
    }


    public JPanel getMainPanel() {
        return mainPanel;
    }

    public ScreenshotUtility getScreenshotUtility() {
        return screenshotUtility;
    }

    public VulnerabilityManager getVulnerabilityManager() {
        return vulnerabilityManager;
    }

    private void loadScanResults() {
        SSLyzeScan.loadScanResults();
        if (SSLyzeScan.getScanOutput() != null) {
            vulnerabilityManager.updateCipherSuitesCount(SSLyzeScan.parseCipherSuites(SSLyzeScan.getScanOutput()));
        }
        updateScanResultsList(); // Dodane, aby zaktualizować listę wyników skanowania w UI
    }

    private void loadLastScannedHost() {
        String lastScannedHost = SSLyzeScan.getLastScannedHost();
        if (lastScannedHost != null) {
            updateXChartDashboard(lastScannedHost);
        }
    }

    public void updateXChartDashboard(String host) {
        List<VulnerabilityStats> vulnerabilities = vulnerabilityManager.getVulnerabilities();
        Map<String, Integer> cipherSuitesCount = vulnerabilityManager.getCipherSuitesCount();
        Logger.log("Updating XChart dashboard with vulnerabilities: " + vulnerabilities);
        Logger.log("Updating XChart dashboard with cipher suites count: " + cipherSuitesCount);
        XChartDashboard xChartDashboard = new XChartDashboard(vulnerabilities, cipherSuitesCount, host); // Przekazanie hosta
        xChartDashboardPanel.removeAll();
        xChartDashboardPanel.add(xChartDashboard.createChartPanel(), BorderLayout.CENTER);
        xChartDashboardPanel.revalidate();
        xChartDashboardPanel.repaint();
    }

    public void updateXChartDashboard() {
        updateXChartDashboard(SSLyzeScan.getLastScannedHost()); // Domyślny host jako ostatnio skanowany host
    }
    
    private JPanel createSearcherPanel() {
        ScreenshotUtility screenshotUtility = getScreenshotUtility();
        Searcher searcher = new Searcher(screenshotUtility);
        return searcher.getMainPanel();
    }


    private static JPanel createAboutPanel() {
        JPanel aboutPanel = new JPanel();
        aboutPanel.setLayout(new BoxLayout(aboutPanel, BoxLayout.Y_AXIS));
        aboutPanel.setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));

        // Tytuł sekcji z paddingiem
        JLabel titleLabel = new JLabel("About This Extension");
        titleLabel.setFont(new Font("Arial", Font.BOLD, 16));
        titleLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        titleLabel.setBorder(BorderFactory.createEmptyBorder(0, 0, 10, 0));
        aboutPanel.add(titleLabel);
        
        // Opis aplikacji
        JTextArea descriptionArea = new JTextArea(
                "This extension is designed to support and enhance security testing processes. It aids in managing documentation, automating tasks, "
                + "and organizing vulnerability assessments, ultimately improving the efficiency and effectiveness of security analysis and reporting.");
        descriptionArea.setWrapStyleWord(true);
        descriptionArea.setLineWrap(true);
        descriptionArea.setOpaque(false);
        descriptionArea.setEditable(false);
        descriptionArea.setFocusable(false);
        descriptionArea.setAlignmentX(Component.LEFT_ALIGNMENT);
        descriptionArea.setBorder(BorderFactory.createEmptyBorder(0, 0, 20, 0));
        aboutPanel.add(descriptionArea);
        
        // Tytuł sekcji funkcjonalności
        JLabel functionalitiesLabel = new JLabel("Functionalities");
        functionalitiesLabel.setFont(new Font("Arial", Font.BOLD, 18));
        functionalitiesLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        functionalitiesLabel.setBorder(BorderFactory.createEmptyBorder(0, 0, 10, 0));
        aboutPanel.add(functionalitiesLabel);

        // Dodanie funkcjonalności
        aboutPanel.add(createFunctionalityComponent("Creating Screenshots", "\r\n"
        		+ "The Screenshot functionality is designed to capture and save screenshots of HTTP requests and responses within Burp Suite. It allows customization of settings, such as maximizing the window for better capture quality, adjusting the aspect ratio, and setting up filename prompts. Keywords can be managed to trigger the creation of specific directories based on their presence or absence in the content. To use this feature, right-click in the Repeater window and select \"Capture Screenshot\" or \"Capture Full Screenshot,\" which also creates a folder for the respective host."));
        aboutPanel.add(createFunctionalityComponent("List of ulnerabilities", "The \"Vulnerabilities\" tab is used to manage and analyze a list of detected vulnerabilities. Vulnerabilities are displayed in a table, categorized by type, risk level, URL, and discovery time. Actions such as adding, editing, removing, and sorting vulnerabilities based on risk level are supported. Visualization through charts and options for saving, loading, and clearing the list of vulnerabilities are provided. Additionally, context menus and double-click actions facilitate interaction with the data."));
        aboutPanel.add(createFunctionalityComponent("Vulnerabilities analytics", "The \"Vulnerability Analytics\" tool is utilized to analyze and visualize security vulnerabilities across different risk levels, types, and time periods. Various charts, including pie charts, bar graphs, and line charts, are generated to help understand trends and distributions of vulnerabilities. SSL/TLS configurations for a scanned host can also be visualized. The output is presented in a user-friendly interface that supports dynamic updates based on the selected time range or specific criteria."));
        aboutPanel.add(createFunctionalityComponent("TLS/SSL configuration canner", "The \"TLS/SSL Configuration Scanner\" analyzes the TLS/SSL setup of a given host using SSLyze, checking for insecure or weak cipher suites and logging any vulnerabilities found. The scan results are visually represented on a chart for easier interpretation. Proper functionality of the scanner requires SSLyze to be installed on the system, with the executable included in the system's PATH environment variable, ensuring that SSLyze can be run and its output processed seamlessly."));
        aboutPanel.add(createFunctionalityComponent("Searcher", "The \"Searcher\" module is designed to search for specific keywords within saved screenshot files. Optical Character Recognition (OCR) through the Tesseract library is used to convert text in images into searchable data. Once the search is initiated, it scans through screenshots in the designated folder and reports which files contain the specified keywords."));
        aboutPanel.add(createFunctionalityComponent("Settings", "The \"Settings\" panel allows for customization of various aspects of the tool's behavior. It provides configuration options for saving paths for vulnerability data and screenshots, managing screenshot settings such as window maximization and aspect ratio, and defining how keywords should be handled in screenshots. The panel also offers the option to reset the entire project, including vulnerabilities and settings, and allows management of the list of keywords used to trigger specific screenshot actions."));
        
        return aboutPanel;
    }

    private static JPanel createFunctionalityComponent(String functionalityName, String functionalityDescription) {
        JPanel functionalityPanel = new JPanel();
        functionalityPanel.setLayout(new BoxLayout(functionalityPanel, BoxLayout.Y_AXIS));
        functionalityPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        functionalityPanel.setBorder(BorderFactory.createEmptyBorder(10, 20, 10, 0)); // Padding 20px from the left

        JLabel nameLabel = new JLabel(functionalityName);
        nameLabel.setFont(new Font("Arial", Font.BOLD, 14));
        nameLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        
        JTextArea descriptionArea = new JTextArea(functionalityDescription);
        descriptionArea.setWrapStyleWord(true);
        descriptionArea.setLineWrap(true);
        descriptionArea.setOpaque(false);
        descriptionArea.setEditable(false);
        descriptionArea.setFocusable(false);
        descriptionArea.setFont(new Font("Arial", Font.PLAIN, 12));
        descriptionArea.setAlignmentX(Component.LEFT_ALIGNMENT);

        functionalityPanel.add(nameLabel);
        functionalityPanel.add(descriptionArea);

        return functionalityPanel;
    }


    private JPanel createSettingsPanel() {
        JPanel settingsPanel = new JPanel(new BorderLayout());

        // Panel dla ścieżek folderów
        JPanel pathSettingsPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbcPath = new GridBagConstraints();
        gbcPath.insets = new Insets(5, 5, 5, 5); // Marginesy między elementami
        gbcPath.anchor = GridBagConstraints.WEST;

        saveFolderTableDataPathLabel = new JLabel("Save Folder Path: None");
        saveScreenshotFolderPathLabel = new JLabel("Save Folder Path: None");
        updateSaveFolderPathLabel();
        updateSaveScreenshotFolderPathLabel();

        JButton selectSaveFolderButton = new JButton("Select folder");
        selectSaveFolderButton.addActionListener(e -> {
            selectSaveFolder();
            saveVulnerabilities(); // Automatyczny zapis po wyborze folderu
        });

        JButton selectSaveFolderButtonForScreenshots = new JButton("Select folder");
        selectSaveFolderButtonForScreenshots.addActionListener(e -> {
            chooseSaveFolderForScreenshots();
        });

        gbcPath.gridx = 0;
        gbcPath.gridy = 0;
        pathSettingsPanel.add(new JLabel("Select a folder to save data from the list of vulnerabilities:"), gbcPath);

        gbcPath.gridx = 1;
        pathSettingsPanel.add(selectSaveFolderButton, gbcPath);

        gbcPath.gridx = 2;
        pathSettingsPanel.add(saveFolderTableDataPathLabel, gbcPath);

        gbcPath.gridx = 0;
        gbcPath.gridy = 1;
        pathSettingsPanel.add(new JLabel("Select folder to save screenshots:"), gbcPath);

        gbcPath.gridx = 1;
        pathSettingsPanel.add(selectSaveFolderButtonForScreenshots, gbcPath);

        gbcPath.gridx = 2;
        pathSettingsPanel.add(saveScreenshotFolderPathLabel, gbcPath);

        // Panel dla przełączników
        JPanel switchSettingsPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbcSwitch = new GridBagConstraints();
        gbcSwitch.insets = new Insets(5, 5, 5, 5); // Marginesy między elementami
        gbcSwitch.anchor = GridBagConstraints.CENTER;
        gbcSwitch.gridx = 0;
        gbcSwitch.gridy = 0;

        includeFullScreenshotCheckbox = new JCheckBox("Include screenshot with whole request and response");
        includeFullScreenshotCheckbox.setSelected(screenshotUtility.includeFullScreenshot);
        includeFullScreenshotCheckbox.addActionListener(e -> {
            screenshotUtility.setIncludeFullScreenshot(includeFullScreenshotCheckbox.isSelected());
            saveSetting(INCLUDE_FULL_SCREENSHOT_KEY, includeFullScreenshotCheckbox.isSelected());
        });
        switchSettingsPanel.add(includeFullScreenshotCheckbox, gbcSwitch);

        gbcSwitch.gridy++;
        maximizeWindowCheckbox = new JCheckBox("Maximize window for screenshots");
        maximizeWindowCheckbox.setSelected(screenshotUtility.isMaximizeWindow());
        maximizeWindowCheckbox.addActionListener(e -> {
            screenshotUtility.setMaximizeWindow(maximizeWindowCheckbox.isSelected());
            saveSetting("maximizeWindow", maximizeWindowCheckbox.isSelected());
        });
        switchSettingsPanel.add(maximizeWindowCheckbox, gbcSwitch);
        
        gbcSwitch.gridy++;
        promptForFilenameCheckbox = new JCheckBox("Prompt for screenshot filename");
        promptForFilenameCheckbox.setSelected(screenshotUtility.isPromptForFilename());
        promptForFilenameCheckbox.addActionListener(e -> {
            screenshotUtility.setPromptForFilename(promptForFilenameCheckbox.isSelected());
            saveSetting("promptForFilename", promptForFilenameCheckbox.isSelected());
        });
        switchSettingsPanel.add(promptForFilenameCheckbox, gbcSwitch);
        
        gbcSwitch.gridy++;
        enableScreenshotNumberingCheckbox = new JCheckBox("Enable screenshot numbering");
        enableScreenshotNumberingCheckbox.setSelected(screenshotUtility.isEnableScreenshotNumbering());
        enableScreenshotNumberingCheckbox.addActionListener(e -> {
            screenshotUtility.setEnableScreenshotNumbering(enableScreenshotNumberingCheckbox.isSelected());
            saveSetting("enableScreenshotNumbering", enableScreenshotNumberingCheckbox.isSelected());
        });
        switchSettingsPanel.add(enableScreenshotNumberingCheckbox, gbcSwitch);
        
        gbcSwitch.gridy++;
        enableScreenshotCroppingCheckbox = new JCheckBox("Enable screenshot cropping and splitting");
        enableScreenshotCroppingCheckbox.setSelected(screenshotUtility.isEnableScreenshotCropping());
        enableScreenshotCroppingCheckbox.addActionListener(e -> {
            boolean screenshotCroppingEnabled = enableScreenshotCroppingCheckbox.isSelected();
            screenshotUtility.setEnableScreenshotCropping(screenshotCroppingEnabled);
            saveSetting("enableScreenshotCropping", screenshotCroppingEnabled);

            if (screenshotCroppingEnabled && enableAspectRatioCheckbox.isSelected()) {
                // Disable aspect ratio if screenshot cropping is enabled
                enableAspectRatioCheckbox.setSelected(false);
                screenshotUtility.setEnableAspectRatio(false);
                saveSetting("enableAspectRatio", false);
                JOptionPane.showMessageDialog(null, "Aspect ratio has been disabled because screenshot cropping is enabled.", "Notice", JOptionPane.INFORMATION_MESSAGE);
            }
        });
        switchSettingsPanel.add(enableScreenshotCroppingCheckbox, gbcSwitch);
        
        gbcSwitch.gridy++;
        enableAspectRatioCheckbox = new JCheckBox("Enable aspect ratio");
        enableAspectRatioCheckbox.setSelected(screenshotUtility.isEnableAspectRatio());
        enableAspectRatioCheckbox.addActionListener(e -> {
            boolean aspectRatioEnabled = enableAspectRatioCheckbox.isSelected();
            screenshotUtility.setEnableAspectRatio(aspectRatioEnabled);
            saveSetting("enableAspectRatio", aspectRatioEnabled);

            if (aspectRatioEnabled && enableScreenshotCroppingCheckbox.isSelected()) {
                // Disable screenshot cropping if aspect ratio is enabled
                enableScreenshotCroppingCheckbox.setSelected(false);
                screenshotUtility.setEnableScreenshotCropping(false);
                saveSetting("enableScreenshotCropping", false);
                JOptionPane.showMessageDialog(null, "Screenshot cropping has been disabled because aspect ratio is enabled.", "Notice", JOptionPane.INFORMATION_MESSAGE);
            }
        });
        switchSettingsPanel.add(enableAspectRatioCheckbox, gbcSwitch);

        // Dodaj pola do ustawienia proporcji obrazu
        gbcSwitch.gridy++;
        JPanel aspectRatioPanel = new JPanel(new FlowLayout());
        aspectRatioWidthField = new JTextField(Integer.toString(screenshotUtility.getAspectRatioWidth()), 3);
        aspectRatioHeightField = new JTextField(Integer.toString(screenshotUtility.getAspectRatioHeight()), 3);
        aspectRatioPanel.add(new JLabel("Aspect Ratio: "));
        aspectRatioPanel.add(aspectRatioWidthField);
        aspectRatioPanel.add(new JLabel(":"));
        aspectRatioPanel.add(aspectRatioHeightField);
        JButton setAspectRatioButton = new JButton("Set");
        setAspectRatioButton.addActionListener(e -> {
            try {
                int width = Integer.parseInt(aspectRatioWidthField.getText());
                int height = Integer.parseInt(aspectRatioHeightField.getText());
                screenshotUtility.setAspectRatio(width, height);
                saveAspectRatioSettings(width, height);
                JOptionPane.showMessageDialog(null, "Aspect ratio set to " + width + ":" + height);
            } catch (NumberFormatException ex) {
                JOptionPane.showMessageDialog(null, "Invalid input for aspect ratio", "Error", JOptionPane.ERROR_MESSAGE);
            }
        });
        aspectRatioPanel.add(setAspectRatioButton);
        switchSettingsPanel.add(aspectRatioPanel, gbcSwitch);

        // Panel dla keyword settings
        JPanel keywordSettingsPanel = new JPanel(new BorderLayout());

        JList<KeywordSetting> keywordList = new JList<>(keywordListModel);
        JScrollPane keywordScrollPane = new JScrollPane(keywordList);
        keywordScrollPane.setPreferredSize(new Dimension(300, 150));

        JTextField keywordField = new JTextField(15);
        JCheckBox saveWhenPresentCheckbox = new JCheckBox("Save when present");
        saveWhenPresentCheckbox.setSelected(true);

        JButton addKeywordButton = new JButton("Add keyword");
        addKeywordButton.addActionListener(e -> {
            String keyword = keywordField.getText().trim();
            if (!keyword.isEmpty()) {
                boolean saveWhenPresent = saveWhenPresentCheckbox.isSelected();
                if (screenshotUtility.hasKeywordSetting(keyword, saveWhenPresent)) {
                    JOptionPane.showMessageDialog(null, "This condition already exists for the keyword: " + keyword);
                } else if (screenshotUtility.hasConflictingKeywordSetting(keyword, saveWhenPresent)) {
                    JOptionPane.showMessageDialog(null, "A conflicting condition already exists for the keyword: " + keyword);
                } else {
                    KeywordSetting setting = new KeywordSetting(keyword, saveWhenPresent);
                    keywordListModel.addElement(setting);
                    screenshotUtility.addKeyword(keyword, saveWhenPresent);
                    keywordField.setText("");
                    saveWhenPresentCheckbox.setSelected(true);
                    saveKeywordSettings(); // Save keyword settings
                }
            }
        });

        JButton removeKeywordButton = new JButton("Remove keyword");
        removeKeywordButton.addActionListener(e -> {
            KeywordSetting selected = keywordList.getSelectedValue();
            if (selected != null) {
                keywordListModel.removeElement(selected);
                screenshotUtility.removeKeyword(selected.getKeyword());
                saveKeywordSettings(); // Save keyword settings
            }
        });

        JButton removeAllKeywordsButton = new JButton("Remove all keywords");
        removeAllKeywordsButton.addActionListener(e -> removeAllKeywords());

        JButton addDefaultKeywordsButton = new JButton("Add default keywords");
        addDefaultKeywordsButton.addActionListener(e -> addDefaultKeywords());

        JPanel keywordPanel = new JPanel();
        keywordPanel.add(new JLabel("Keyword:"));
        keywordPanel.add(keywordField);
        keywordPanel.add(saveWhenPresentCheckbox);
        keywordPanel.add(addKeywordButton);
        keywordPanel.add(removeKeywordButton);
        keywordPanel.add(removeAllKeywordsButton);
        keywordPanel.add(addDefaultKeywordsButton);

        keywordSettingsPanel.add(keywordScrollPane, BorderLayout.CENTER);
        keywordSettingsPanel.add(keywordPanel, BorderLayout.SOUTH);

        // Dodanie paneli do głównego panelu ustawień
        settingsPanel.add(pathSettingsPanel, BorderLayout.WEST);
        settingsPanel.add(switchSettingsPanel, BorderLayout.EAST);
        settingsPanel.add(keywordSettingsPanel, BorderLayout.SOUTH);

        // Dodanie przycisku do czyszczenia wszystkich podatności
        JPanel buttonPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbcButton = new GridBagConstraints();
        gbcButton.insets = new Insets(40, 20, 40, 20); // Padding po 20 pikseli z każdej strony
        gbcButton.anchor = GridBagConstraints.EAST;
        gbcButton.gridx = 0;
        gbcButton.gridy = 3;
        gbcButton.weightx = 1; // Rozszerzenie w poziomie
        gbcButton.fill = GridBagConstraints.HORIZONTAL; // Wypełnienie poziome

        JButton clearAllButton = new JButton("Reset project");
        clearAllButton.addActionListener(e -> {
            int confirmation = JOptionPane.showConfirmDialog(null, "Are you sure you want to clear all vulnerabilities and dashboard?", "Confirm Clear", JOptionPane.YES_NO_OPTION);
            if (confirmation == JOptionPane.YES_OPTION) {
                vulnerabilityManager.clearAllVulnerabilities();
                removeAllKeywords();
                SSLyzeScan.clearRawScanResults(); // Dodane, aby wyczyścić surowe wyniki skanowania
                updateScanResultsList(); // Dodane, aby odświeżyć listę wyników skanowania w UI
                scanResultTextArea.setText("");
                clearScanScopeButtons(hostPanel);
            }
        });

        buttonPanel.add(clearAllButton, gbcButton);
        settingsPanel.add(buttonPanel, BorderLayout.NORTH);

        return settingsPanel;
    }

    
    private void clearScanScopeButtons(JPanel hostPanel) {
        hostPanel.removeAll();
        hostPanel.revalidate();
        hostPanel.repaint();
    }


    private void saveAspectRatioSettings(int width, int height) {
        callbacks.saveExtensionSetting("aspectRatioWidth", Integer.toString(width));
        callbacks.saveExtensionSetting("aspectRatioHeight", Integer.toString(height));
    }

    private void addDefaultKeywords() {
        String[] defaultKeywords = {"Strict-Transport-Security", "Content-Security-Policy", "X-Content-Type-Options", "X-Frame-Options", "X-XSS-Protection"};
        for (String keyword : defaultKeywords) {
            boolean saveWhenPresent = false; // We want to ensure these headers are present
            if (!screenshotUtility.hasKeywordSetting(keyword, saveWhenPresent)) {
                KeywordSetting setting = new KeywordSetting(keyword, saveWhenPresent);
                keywordListModel.addElement(setting);
                screenshotUtility.addKeyword(keyword, saveWhenPresent);
            }
        }
        saveKeywordSettings(); // Save keyword settings
    }

    private void removeAllKeywords() {
        keywordListModel.clear();
        screenshotUtility.clearAllKeywords();
        saveKeywordSettings(); // Save keyword settings
    }

    private void updateCheckboxState() {
        boolean includeFullScreenshot = loadSettingAsBoolean(INCLUDE_FULL_SCREENSHOT_KEY, true);
        JCheckBox includeFullScreenshotCheckbox = new JCheckBox("Include screenshot with whole request and response");
        includeFullScreenshotCheckbox.setSelected(includeFullScreenshot);
        includeFullScreenshotCheckbox.addActionListener(e -> {
            screenshotUtility.setIncludeFullScreenshot(includeFullScreenshotCheckbox.isSelected());
            saveSetting(INCLUDE_FULL_SCREENSHOT_KEY, includeFullScreenshotCheckbox.isSelected());
        });
    }

    private void saveSetting(String key, boolean value) {
        callbacks.saveExtensionSetting(key, Boolean.toString(value));
    }


    private boolean loadSettingAsBoolean(String key, boolean defaultValue) {
        String value = callbacks.loadExtensionSetting(key);
        if (value != null) {
            return Boolean.parseBoolean(value);
        }
        return defaultValue;
    }

    private int loadSettingAsInt(String key, int defaultValue) {
        String value = callbacks.loadExtensionSetting(key);
        if (value != null) {
            try {
                return Integer.parseInt(value);
            } catch (NumberFormatException ex) {
                Logger.log("Invalid integer setting for key: " + key);
            }
        }
        return defaultValue;
    }

    public void saveVulnerabilities() {
        Logger.log("[UIComponents] Save button clicked");
        String saveFolderPath = callbacks.loadExtensionSetting(SAVE_FOLDER_PATH_KEY);
        if (saveFolderPath == null || saveFolderPath.isEmpty()) {
            Logger.log("[UIComponents] Save folder path is not set.");
            JOptionPane.showMessageDialog(null, "Save folder path is not set. Please select a save folder first.", "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }
        Logger.log("[UIComponents] Selected save folder path: " + saveFolderPath);
        List<VulnerabilityStats> vulnerabilities = vulnerabilityManager.getVulnerabilities();
        PersistenceManager.saveVulnerabilities(vulnerabilities, saveFolderPath);
    }

    private void loadVulnerabilities() {
        Logger.log("[UIComponents] Load vulnerabilities process started");

        String saveFolderPath = callbacks.loadExtensionSetting(SAVE_FOLDER_PATH_KEY);
        if (saveFolderPath != null && !saveFolderPath.isEmpty()) {
            String loadFilePath = saveFolderPath + "/vulnerabilities.json";
            File file = new File(loadFilePath);
            if (file.exists()) {
                Logger.log("[UIComponents] Found vulnerabilities file: " + loadFilePath);
                List<VulnerabilityStats> vulnerabilities = PersistenceManager.loadVulnerabilities(loadFilePath);
                if (vulnerabilities != null && !vulnerabilities.isEmpty()) {
                    vulnerabilityManager.loadVulnerabilities(vulnerabilities);
                    Logger.log("[UIComponents] Vulnerabilities loaded successfully from " + loadFilePath);
                } else {
                    Logger.log("[UIComponents] No vulnerabilities to load or failed to load vulnerabilities from " + loadFilePath);
                }
            } else {
                Logger.log("[UIComponents] No vulnerabilities file found.");
            }
        } else {
            Logger.log("[UIComponents] No save folder path set.");
        }
    }

    private void selectSaveFolder() {
        Logger.log("[UIComponents] Select Save Folder button clicked");
        String saveFolderPath = FileChooserUtil.chooseFolder("Select folder to save vulnerabilities");
        if (saveFolderPath != null) {
            callbacks.saveExtensionSetting(SAVE_FOLDER_PATH_KEY, saveFolderPath);
            Logger.log("[UIComponents] Selected save folder path: " + saveFolderPath);
            updateSaveFolderPathLabel();
            saveVulnerabilities();
        }
    }

    private void chooseSaveFolderForScreenshots() {
        Logger.log("[UIComponents] Choose Save Folder For Screenshots button clicked");
        String saveFolderPath = FileChooserUtil.chooseFolder("Select folder to save screenshots");
        if (saveFolderPath != null) {
            screenshotUtility.setSaveFolderPath(saveFolderPath);
            callbacks.saveExtensionSetting(SAVE_SCREENSHOT_FOLDER_PATH_KEY, saveFolderPath);
            Logger.log("[UIComponents] Selected save folder path for screenshots: " + saveFolderPath);
            updateSaveScreenshotFolderPathLabel();
        }
    }

    private void updateSaveFolderPathLabel() {
        String saveFolderPath = callbacks.loadExtensionSetting(SAVE_FOLDER_PATH_KEY);
        if (saveFolderPath == null || saveFolderPath.isEmpty()) {
            saveFolderTableDataPathLabel.setText("Save Folder Path: None");
        } else {
            saveFolderTableDataPathLabel.setText("Save Folder Path: " + saveFolderPath);
        }
    }

    public void updateSaveScreenshotFolderPathLabel() {
        String saveFolderPath = callbacks.loadExtensionSetting(SAVE_SCREENSHOT_FOLDER_PATH_KEY); // Load the screenshot folder path
        if (saveFolderPath == null || saveFolderPath.isEmpty()) {
            saveScreenshotFolderPathLabel.setText("Save Folder Path: None");
        } else {
            saveScreenshotFolderPathLabel.setText("Save Folder Path: " + saveFolderPath);
        }
    }

    // Save keyword settings to Burp's extension settings
    private void saveKeywordSettings() {
        Gson gson = new Gson();
        List<KeywordSetting> keywordSettings = new ArrayList<>();
        for (int i = 0; i < keywordListModel.size(); i++) {
            keywordSettings.add(keywordListModel.get(i));
        }
        String json = gson.toJson(keywordSettings);
        callbacks.saveExtensionSetting(KEYWORD_SETTINGS_KEY, json);
    }

    // Load keyword settings from Burp's extension settings
    private void loadKeywordSettings() {
        String json = callbacks.loadExtensionSetting(KEYWORD_SETTINGS_KEY);
        if (json != null && !json.isEmpty()) {
            Gson gson = new Gson();
            Type listType = new TypeToken<ArrayList<KeywordSetting>>() {}.getType();
            List<KeywordSetting> keywordSettings = gson.fromJson(json, listType);
            for (KeywordSetting setting : keywordSettings) {
                keywordListModel.addElement(setting);
                screenshotUtility.addKeyword(setting.getKeyword(), setting.isSaveWhenPresent());
            }
        }
    }

    private void loadSettings() {
        boolean includeFullScreenshot = loadSettingAsBoolean(INCLUDE_FULL_SCREENSHOT_KEY, true);
        screenshotUtility.setIncludeFullScreenshot(includeFullScreenshot);
        if (includeFullScreenshotCheckbox != null) {
            includeFullScreenshotCheckbox.setSelected(includeFullScreenshot);
        }

        boolean maximizeWindow = loadSettingAsBoolean("maximizeWindow", true);
        screenshotUtility.setMaximizeWindow(maximizeWindow);
        if (maximizeWindowCheckbox != null) {
            maximizeWindowCheckbox.setSelected(maximizeWindow);
        }

        boolean enableAspectRatio = loadSettingAsBoolean("enableAspectRatio", false);
        screenshotUtility.setEnableAspectRatio(enableAspectRatio);
        if (enableAspectRatioCheckbox != null) {
            enableAspectRatioCheckbox.setSelected(enableAspectRatio);
        }

        boolean promptForFilename = loadSettingAsBoolean("promptForFilename", false);
        screenshotUtility.setPromptForFilename(promptForFilename);
        if (promptForFilenameCheckbox != null) {
            promptForFilenameCheckbox.setSelected(promptForFilename);
        }

        int aspectRatioWidth = loadSettingAsInt("aspectRatioWidth", 1);
        int aspectRatioHeight = loadSettingAsInt("aspectRatioHeight", 2);
        screenshotUtility.setAspectRatio(aspectRatioWidth, aspectRatioHeight);
        if (aspectRatioWidthField != null) {
            aspectRatioWidthField.setText(Integer.toString(aspectRatioWidth));
        }
        if (aspectRatioHeightField != null) {
            aspectRatioHeightField.setText(Integer.toString(aspectRatioHeight));
        }
        
        boolean enableScreenshotNumbering = loadSettingAsBoolean("enableScreenshotNumbering", true);
        screenshotUtility.setEnableScreenshotNumbering(enableScreenshotNumbering);
        if (enableScreenshotNumberingCheckbox != null) {
            enableScreenshotNumberingCheckbox.setSelected(enableScreenshotNumbering);
        }
        
        boolean enableScreenshotCropping = loadSettingAsBoolean("enableScreenshotCropping", false);
        screenshotUtility.setEnableScreenshotCropping(enableScreenshotCropping);
        if (enableScreenshotCroppingCheckbox != null) {
            enableScreenshotCroppingCheckbox.setSelected(enableScreenshotCropping);
        }
    }




    // Inner class to represent keyword settings
    private class KeywordSetting {
        private String keyword;
        private boolean saveWhenPresent;

        public KeywordSetting(String keyword, boolean saveWhenPresent) {
            this.keyword = keyword;
            this.saveWhenPresent = saveWhenPresent;
        }

        public String getKeyword() {
            return keyword;
        }

        public boolean isSaveWhenPresent() {
            return saveWhenPresent;
        }

        @Override
        public String toString() {
            return keyword + (saveWhenPresent ? " (save when present)" : " (save when absent)");
        }
    }

    private JPanel createTLSCheckerPanel() {
        int padding = 20; // Zwiększony ogólny padding
        int smallGap = 20; // Mała przerwa między komponentami

        JPanel tlsPanel = new JPanel(new BorderLayout());
        tlsPanel.setBorder(BorderFactory.createEmptyBorder(padding, padding, padding, padding));

        // Górny panel z polem tekstowym i przyciskiem do skanowania custom hosta
        JPanel customHostPanel = new JPanel();
        customHostPanel.setLayout(new BoxLayout(customHostPanel, BoxLayout.X_AXIS));
        customHostPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, smallGap + 10, 0)); // Padding z obu stron, 10 dodatkowych pikseli na dole

        JTextField hostTextField = new JTextField();
        hostTextField.setMaximumSize(new Dimension(Integer.MAX_VALUE, hostTextField.getPreferredSize().height));
        JButton scanCustomHostButton = new JButton("Launch Scan for Custom Host");

        scanCustomHostButton.addActionListener(e -> {
            String customHost = hostTextField.getText().trim();
            if (!customHost.isEmpty()) {
                Logger.log("Initiating scan for custom host: " + customHost);
                SSLyzeScan.runAndProcessSSLyzeScan(customHost, vulnerabilityManager);
                updateXChartDashboard(customHost); // Aktualizacja z nazwą hosta
                updateScanResultsList();
            } else {
                Logger.log("No custom host provided.");
            }
        });

        customHostPanel.add(new JLabel("Host to scan: "));
        customHostPanel.add(Box.createRigidArea(new Dimension(smallGap, 0)));
        customHostPanel.add(hostTextField);
        customHostPanel.add(Box.createRigidArea(new Dimension(smallGap, 0)));
        customHostPanel.add(scanCustomHostButton);

        // Panel z przyciskami dla hostów z vulnerabilities
        hostPanel = new JPanel(); // Zmieniono na pole klasy
        hostPanel.setLayout(new BoxLayout(hostPanel, BoxLayout.Y_AXIS));
        hostPanel.setBorder(BorderFactory.createTitledBorder("Scan from the scope"));

        // Dodanie początkowego odstępu dla pierwszego przycisku
        hostPanel.add(Box.createVerticalStrut(smallGap));

        for (String host : vulnerabilityManager.getHosts()) {
            JButton scanButton = new JButton(host);
            scanButton.setAlignmentX(Component.CENTER_ALIGNMENT);
            scanButton.addActionListener(e -> {
                Logger.log("Initiating scan for host: " + host);
                SSLyzeScan.runAndProcessSSLyzeScan(host, vulnerabilityManager);
                updateXChartDashboard(host); // Aktualizacja z nazwą hosta
                updateScanResultsList();
            });
            hostPanel.add(scanButton);
            hostPanel.add(Box.createRigidArea(new Dimension(0, smallGap))); // Odstęp między przyciskami
        }

        // Panel z listą wyników skanów i obszarem tekstowym do ich przeglądania
        JPanel resultsPanel = new JPanel(new BorderLayout());
        resultsPanel.setBorder(BorderFactory.createTitledBorder("Already scanned hosts"));

        scanResultsList = new JList<>();
        scanResultsList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        scanResultsList.addListSelectionListener(e -> {
            String selectedHost = scanResultsList.getSelectedValue();
            if (selectedHost != null) {
                scanResultTextArea.setText(SSLyzeScan.getRawScanResults().get(selectedHost)); // Użycie surowych wyników skanów
                scanResultTextArea.setCaretPosition(0); // Przewinięcie na początek
            }
        });

        JScrollPane scanResultsListScrollPane = new JScrollPane(scanResultsList);
        scanResultsListScrollPane.setBorder(BorderFactory.createEmptyBorder(0, smallGap, 0, smallGap)); // Dodanie odstępu od lewej i prawej strony

        resultsPanel.add(scanResultsListScrollPane, BorderLayout.CENTER);

        // Utworzenie JSplitPane pomiędzy "Scan from the scope" i "Already scanned hosts"
        JSplitPane innerSplitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, hostPanel, resultsPanel);
        innerSplitPane.setResizeWeight(0.3); // Domyślnie ustawione na 30% dla "Scan from the scope" i 70% dla "Already scanned hosts"
        innerSplitPane.setOneTouchExpandable(true); // Dodanie przycisków do rozszerzania
        innerSplitPane.setDividerLocation(300); // Początkowa szerokość dla "Scan from the scope"

        // Panel na surowy output skanu
        JPanel rawScanPanel = new JPanel(new BorderLayout());
        rawScanPanel.setBorder(BorderFactory.createTitledBorder("Raw Scan Output"));

        scanResultTextArea = new JTextArea();
        scanResultTextArea.setEditable(false);
        scanResultTextArea.setLineWrap(true);
        scanResultTextArea.setWrapStyleWord(true);
        JScrollPane rawScanScrollPane = new JScrollPane(scanResultTextArea);

        rawScanPanel.add(rawScanScrollPane, BorderLayout.CENTER);

        // Utworzenie JSplitPane dla dynamicznej zmiany szerokości
        JSplitPane outerSplitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, innerSplitPane, rawScanPanel);
        outerSplitPane.setResizeWeight(0.5); // Domyślnie ustawione na 50% dla obu stron
        outerSplitPane.setOneTouchExpandable(true); // Dodanie przycisków do rozszerzania
        outerSplitPane.setDividerLocation(800); // Początkowa szerokość dla lewej strony

        JPanel mainContentPanel = new JPanel(new BorderLayout());
        mainContentPanel.add(customHostPanel, BorderLayout.NORTH);
        mainContentPanel.add(outerSplitPane, BorderLayout.CENTER);

        tlsPanel.add(mainContentPanel, BorderLayout.CENTER);

        return tlsPanel;
    }

    public void updateScanResultsList() {
        DefaultListModel<String> listModel = new DefaultListModel<>();
        for (String host : SSLyzeScan.getRawScanResults().keySet()) {
            listModel.addElement(host);
        }
        scanResultsList.setModel(listModel);
    }

    public void refreshTLSCheckerPanel() {
        JPanel tlsCheckerPanel = createTLSCheckerPanel();
        JTabbedPane mainTabs = (JTabbedPane) mainPanel.getComponent(0);
        for (int i = 0; i < mainTabs.getTabCount(); i++) {
            if (mainTabs.getTitleAt(i).equals("TLS/SSL configuration scanner")) {
                mainTabs.setComponentAt(i, tlsCheckerPanel);
                break;
            }
        }
    }
}
