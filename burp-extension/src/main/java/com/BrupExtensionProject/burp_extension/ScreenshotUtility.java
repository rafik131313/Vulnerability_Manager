package com.BrupExtensionProject.burp_extension;

import burp.IBurpExtenderCallbacks;
import burp.IHttpRequestResponse;
import org.imgscalr.Scalr;

import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ScreenshotUtility {
    private IBurpExtenderCallbacks callbacks;
    private String saveFolderPath = ""; // Default save path
    private ExtensionSharedParameters sharedParameters;
    private Map<String, Boolean> keywordSettings; // Map to store keywords and their settings
    boolean includeFullScreenshot = true; // New setting switch
    private boolean maximizeWindow = true; // New setting switch for maximizing window
    private int aspectRatioWidth = 16; // Default aspect ratio width
    private int aspectRatioHeight = 9; // Default aspect ratio height
    private boolean enableAspectRatio = false;
    private boolean promptForFilename = false; // New setting for prompting filename
    private boolean enableScreenshotNumbering = true; // New setting for numbering screenshots
    private boolean enableScreenshotCropping = false;
    private String lastFilename = "";


    public ScreenshotUtility(IBurpExtenderCallbacks callbacks) {
        this.callbacks = callbacks;
        this.sharedParameters = new ExtensionSharedParameters(callbacks);
        this.keywordSettings = new HashMap<>();
    }

    public void setMaximizeWindow(boolean maximizeWindow) {
        this.maximizeWindow = maximizeWindow;
    }

    public boolean isMaximizeWindow() {
        return maximizeWindow;
    }
    
    public void setEnableScreenshotCropping(boolean enableScreenshotCropping) {
        this.enableScreenshotCropping = enableScreenshotCropping;
    }

    public boolean isEnableScreenshotCropping() {
        return enableScreenshotCropping;
    }
    
    public void setAspectRatio(int width, int height) {
        this.aspectRatioWidth = width;
        this.aspectRatioHeight = height;
    }

    public int getAspectRatioWidth() {
        return aspectRatioWidth;
    }

    public int getAspectRatioHeight() {
        return aspectRatioHeight;
    }
    
    public void setEnableAspectRatio(boolean enable) {
        this.enableAspectRatio = enable;
    }

    public boolean isEnableAspectRatio() {
        return enableAspectRatio;
    }

    public void setPromptForFilename(boolean promptForFilename) {
        this.promptForFilename = promptForFilename;
    }

    public boolean isPromptForFilename() {
        return promptForFilename;
    }

    public void setEnableScreenshotNumbering(boolean enableScreenshotNumbering) {
        this.enableScreenshotNumbering = enableScreenshotNumbering;
    }

    public boolean isEnableScreenshotNumbering() {
        return enableScreenshotNumbering;
    }

    public void captureFullScreenshot(IHttpRequestResponse requestResponse) {
        try {
            String request = new String(requestResponse.getRequest());
            String response = new String(requestResponse.getResponse());
            String fullContent = "Request:\n" + request + "\n\nResponse:\n" + response;

            BufferedImage image = textToImage(fullContent);
            String host = extractHostFromRequest(request);
            if (host != null) {
                String folderPath = saveFolderPath + "/" + host;
                File folder = new File(folderPath);
                if (!folder.exists()) {
                    folder.mkdirs();
                }

                String strDate = new SimpleDateFormat("dd-MM-yyyy-HH-mm").format(new Date());
                final String[] baseFilename = { "screenshot" };
                if (promptForFilename) {
                    String input = JOptionPane.showInputDialog(null, 
                        "Enter filename (without extension):", 
                        "Screenshot Filename",
                        JOptionPane.INFORMATION_MESSAGE, 
                        null, 
                        null, 
                        lastFilename).toString();
                    if (input != null && !input.trim().isEmpty()) {
                        baseFilename[0] = input.trim();
                        lastFilename = baseFilename[0]; // Store the last used filename
                    }
                }

                if (enableScreenshotNumbering) {
                    baseFilename[0] = generateUniqueFilename(folderPath, baseFilename[0]);
                } else {
                    // Generate a random UUID if numbering is disabled
                    baseFilename[0] = baseFilename[0] + "-" + UUID.randomUUID().toString().substring(0, 8);
                }

                // Generujemy wspólną nazwę pliku
                String screenshotFilePath = folderPath + "/" + baseFilename[0] + "-" + strDate + ".png";
                String fullScreenshotFilePath = folderPath + "/Full_Screenshot_" + baseFilename[0] + "-" + strDate + ".png";

                // Capture and save regular screenshot
                captureScreenshot(folderPath, screenshotFilePath, baseFilename[0]);

                if (includeFullScreenshot) {
                    ImageIO.write(image, "png", new File(fullScreenshotFilePath));
                    Logger.log("Full screenshot saved to: " + new File(fullScreenshotFilePath).getAbsolutePath());
                }

                for (Map.Entry<String, Boolean> entry : keywordSettings.entrySet()) {
                    String keyword = entry.getKey();
                    boolean saveWhenPresent = entry.getValue();
                    if ((saveWhenPresent && fullContent.contains(keyword)) || (!saveWhenPresent && !fullContent.contains(keyword))) {
                        String keywordFolderPath = folderPath + (saveWhenPresent ? "/" + keyword + "_exists" : "/Lack_of_" + keyword);
                        File keywordFolder = new File(keywordFolderPath);
                        if (!keywordFolder.exists()) {
                            keywordFolder.mkdirs();
                        }

                        // Wykorzystujemy wygenerowane `baseFilename` w folderze keyword
                        String keywordScreenshotFilePath = keywordFolderPath + "/" + baseFilename[0] + "-" + strDate + ".png";
                        String keywordFullScreenshotFilePath = keywordFolderPath + "/Full_Screenshot_" + baseFilename[0] + "-" + strDate + ".png";

                        if (includeFullScreenshot) {
                            ImageIO.write(image, "png", new File(keywordFullScreenshotFilePath));
                            Logger.log("Full screenshot saved to: " + new File(keywordFullScreenshotFilePath).getAbsolutePath());
                        }

                        // Capture and save regular screenshot in the keyword folder
                        captureScreenshot(keywordFolderPath, keywordScreenshotFilePath, baseFilename[0]);
                    }
                }
            } else {
                callbacks.printError("Host header not found in request.");
            }
        } catch (IOException e) {
            callbacks.printError("Error saving screenshot: " + e.getMessage());
        }
    }




    public void captureScreenshot(String folderPath, String specifiedFilePath, String baseFilename) {
        Logger.log("Starting captureScreenshot with folderPath: " + folderPath);

        JFrame mainFrame = getBurpSuiteMainFrame();
        int originalState = mainFrame.getExtendedState();
        if (maximizeWindow) {
            mainFrame.setExtendedState(JFrame.MAXIMIZED_BOTH);
        }

        final String[] effectiveBaseFilename = { baseFilename }; // Use an array to store the base filename

        Timer timer = new Timer(100, e -> {
            if (!maximizeWindow || mainFrame.getExtendedState() == JFrame.MAXIMIZED_BOTH) {
                ((Timer) e.getSource()).stop();

                try {
                    JTabbedPane repeaterPane = findRepeaterPane();
                    if (repeaterPane != null) {
                        Logger.log("Repeater pane found.");

                        SubTabsContainerHandler selectedTabHandler = findSelectedTabHandler(repeaterPane);
                        if (selectedTabHandler != null) {
                            Logger.log("Selected tab handler found.");

                            Component requestComponent = selectedTabHandler.currentTabContainer;

                            if (requestComponent != null) {
                                Logger.log("Request component found.");

                                BufferedImage bufferedImage = new BufferedImage(requestComponent.getWidth(), requestComponent.getHeight(), BufferedImage.TYPE_INT_ARGB);
                                Graphics g = bufferedImage.createGraphics();
                                requestComponent.paint(g);
                                g.dispose();

                                // Apply aspect ratio if enabled
                                BufferedImage finalImage;
                                if (enableAspectRatio) {
                                    int newWidth = bufferedImage.getWidth();
                                    int newHeight = (newWidth * aspectRatioHeight) / aspectRatioWidth;
                                    finalImage = Scalr.resize(bufferedImage, Scalr.Method.QUALITY, Scalr.Mode.FIT_EXACT, newWidth, newHeight);
                                    Logger.log("Image resized using Imgscalr to aspect ratio " + aspectRatioWidth + ":" + aspectRatioHeight);
                                } else {
                                    finalImage = bufferedImage;
                                }

                                String strDate = new SimpleDateFormat("dd-MM-yyyy-HH-mm").format(new Date());
                                if (effectiveBaseFilename[0] == null) {
                                    effectiveBaseFilename[0] = "screenshot";
                                    if (promptForFilename) {
                                        String input = JOptionPane.showInputDialog(null, 
                                            "Enter filename (without extension):", 
                                            "Screenshot Filename",
                                            JOptionPane.INFORMATION_MESSAGE, 
                                            null, 
                                            null, 
                                            lastFilename).toString();
                                        if (input != null && !input.trim().isEmpty()) {
                                            effectiveBaseFilename[0] = input.trim();
                                            lastFilename = effectiveBaseFilename[0]; // Store the last used filename
                                        }
                                    }

                                    if (enableScreenshotNumbering) {
                                        effectiveBaseFilename[0] = generateUniqueFilename(folderPath, effectiveBaseFilename[0]);
                                    } else {
                                        // Generate random UUID when numbering is not enabled
                                        effectiveBaseFilename[0] = effectiveBaseFilename[0] + "-" + UUID.randomUUID().toString().substring(0, 8);
                                    }
                                }

                                if (enableScreenshotCropping) {
                                    // Cropping and splitting logic should always be applied if enabled
                                    String requestFilename = effectiveBaseFilename[0] + "_[Request]-" + strDate;
                                    String responseFilename = effectiveBaseFilename[0] + "_[Response]-" + strDate;

                                    int cropWidth = finalImage.getWidth() - 40; // Crop 40 pixels from the right
                                    int cropHeight = finalImage.getHeight() - 75 - 30; // Crop 75 pixels from the top and 30 pixels from the bottom
                                    BufferedImage croppedImage = finalImage.getSubimage(0, 75, cropWidth, cropHeight);

                                    int halfWidth = cropWidth / 2;

                                 // Left part (Request)
                                    String requestFileLocation = folderPath + "/" + requestFilename + ".png";
                                    BufferedImage requestImage = croppedImage.getSubimage(0, 0, halfWidth - 3, croppedImage.getHeight()); // Zmniejsz szerokość o 3 piksele
                                    ImageIO.write(requestImage, "png", new File(requestFileLocation));
                                    callbacks.printOutput("Request part saved successfully: " + new File(requestFileLocation).getAbsolutePath());

                                    // Right part (Response)
                                    String responseFileLocation = folderPath + "/" + responseFilename + ".png";
                                    BufferedImage responseImage = croppedImage.getSubimage(halfWidth - 3, 0, halfWidth + 3, croppedImage.getHeight()); // Punkt początkowy przesunięty o 3 piksele
                                    ImageIO.write(responseImage, "png", new File(responseFileLocation));
                                    callbacks.printOutput("Response part saved successfully: " + new File(responseFileLocation).getAbsolutePath());



                                } else {
                                    // Zapisanie pełnego zrzutu bez dzielenia
                                    String finalImageFileLocation = specifiedFilePath != null ? specifiedFilePath : folderPath + "/" + effectiveBaseFilename[0] + "-" + strDate + ".png";
                                    try (FileOutputStream fos = new FileOutputStream(finalImageFileLocation)) {
                                        ImageIO.write(finalImage, "png", fos);
                                        callbacks.printOutput("Image file saved successfully: " + new File(finalImageFileLocation).getAbsolutePath());
                                        Logger.log("Image saved to: " + new File(finalImageFileLocation).getAbsolutePath());
                                    } catch (IOException ex) {
                                        callbacks.printError("Image file could not be saved: " + finalImageFileLocation);
                                        callbacks.printError(ex.getMessage());
                                        Logger.log("Error saving image: " + ex.getMessage());
                                    }
                                }

                            } else {
                                callbacks.printError("Request component is null");
                                Logger.log("Request component is null.");
                            }
                        } else {
                            callbacks.printError("Selected tab handler is null");
                            Logger.log("Selected tab handler is null.");
                        }
                    } else {
                        callbacks.printError("Repeater pane not found");
                        Logger.log("Repeater pane not found.");
                    }
                } catch (Exception ex) {
                    callbacks.printError("Error capturing request screenshot: " + ex.getMessage());
                    Logger.log("Error capturing request screenshot: " + ex.getMessage());
                } finally {
                    if (maximizeWindow) {
                        mainFrame.setExtendedState(originalState); // Przywrócenie poprzedniego stanu okna
                    }
                }
            }
        });

        timer.setRepeats(true);
        timer.start();
        Logger.log("Timer started for captureScreenshot.");
    }






    private String generateUniqueFilename(String folderPath, String baseFilename) {
        int counter = 1;

        // Iterujemy przez wszystkie pliki w folderze
        File folder = new File(folderPath);
        File[] files = folder.listFiles((dir, name) -> name.startsWith(baseFilename + "_") && name.endsWith(".png"));

        if (files != null) {
            for (File file : files) {
                String filename = file.getName();
                // Usuwanie daty i pozostałych części po numerze
                String filenameWithoutDate = filename.replaceFirst("-\\d{2}-\\d{2}-\\d{4}-\\d{2}-\\d{2}\\.png$", "");

                try {
                    String[] parts = filenameWithoutDate.split("_");
                    int fileCounter = Integer.parseInt(parts[1]); // Numerowanie jest na pozycji 2 po podziale na "_"
                    if (fileCounter >= counter) {
                        counter = fileCounter + 1;
                    }
                } catch (NumberFormatException e) {
                    // Ignorowanie plików, które nie mają poprawnego numeru na końcu
                }
            }
        }

        // Zwracamy nazwę pliku z poprawnym numerem
        return baseFilename + "_" + counter;
    }



    private BufferedImage textToImage(String text) {
        Font font = new Font("Arial", Font.PLAIN, 12);
        String[] lines = text.split("\n");

        // Create a temporary image to get FontMetrics
        BufferedImage tempImage = new BufferedImage(1, 1, BufferedImage.TYPE_INT_RGB);
        Graphics2D g2d = tempImage.createGraphics();
        g2d.setFont(font);
        FontMetrics metrics = g2d.getFontMetrics();

        int maxWidth = 0;
        for (String line : lines) {
            int width = metrics.stringWidth(line);
            if (width > maxWidth) {
                maxWidth = width;
            }
        }
        int lineHeight = metrics.getHeight();
        int imageHeight = lineHeight * lines.length;

        // Add padding
        maxWidth += 20;
        imageHeight += 20;

        // Create the actual image
        BufferedImage image = new BufferedImage(maxWidth, imageHeight, BufferedImage.TYPE_INT_RGB);
        g2d = image.createGraphics();

        g2d.setColor(Color.WHITE);
        g2d.fillRect(0, 0, maxWidth, imageHeight);
        g2d.setColor(Color.BLACK);
        g2d.setFont(font);

        int y = lineHeight;
        for (String line : lines) {
            g2d.drawString(line, 10, y); // Add padding to the left
            y += lineHeight;
        }

        g2d.dispose();
        return image;
    }

    private String extractHostFromRequest(String request) {
        Pattern pattern = Pattern.compile("Host: ([^\\s]+)");
        Matcher matcher = pattern.matcher(request);
        if (matcher.find()) {
            return matcher.group(1);
        }
        return null;
    }

    private SubTabsContainerHandler findSelectedTabHandler(JTabbedPane repeaterPane) {
        for (int i = 0; i < repeaterPane.getTabCount(); i++) {
            Component component = repeaterPane.getComponentAt(i);
            if (component.isShowing()) {
                return new SubTabsContainerHandler(sharedParameters, repeaterPane, i, false);
            }
        }
        return null;
    }

    private JTabbedPane findRepeaterPane() {
        JFrame mainFrame = getBurpSuiteMainFrame();
        if (mainFrame != null) {
            JRootPane rootPane = mainFrame.getRootPane();
            return findRepeaterPaneInComponent(rootPane);
        }
        return null;
    }

    private JTabbedPane findRepeaterPaneInComponent(Container container) {
        for (Component component : container.getComponents()) {
            if (component instanceof JTabbedPane) {
                JTabbedPane tabbedPane = (JTabbedPane) component;
                for (int i = 0; i < tabbedPane.getTabCount(); i++) {
                    String title = tabbedPane.getTitleAt(i);
                    if (title != null && title.contains("Repeater")) {
                        return tabbedPane;
                    }
                }
            } else if (component instanceof Container) {
                JTabbedPane pane = findRepeaterPaneInComponent((Container) component);
                if (pane != null) {
                    return pane;
                }
            }
        }
        return null;
    }

    private JFrame getBurpSuiteMainFrame() {
        for (Frame frame : Frame.getFrames()) {
            if (frame instanceof JFrame && frame.isVisible() && frame.getTitle().contains("Burp Suite")) {
                return (JFrame) frame;
            }
        }
        return null;
    }

    public void setSaveFolderPath(String saveFolderPath) {
        this.saveFolderPath = saveFolderPath;
    }

    public String getSaveFolderPath() {
        return saveFolderPath;
    }

    public void addKeyword(String keyword, boolean saveWhenPresent) {
        keywordSettings.put(keyword, saveWhenPresent);
    }

    public void removeKeyword(String keyword) {
        keywordSettings.remove(keyword);
    }

    public boolean hasKeywordSetting(String keyword, boolean saveWhenPresent) {
        return keywordSettings.containsKey(keyword) && keywordSettings.get(keyword) == saveWhenPresent;
    }

    public boolean hasConflictingKeywordSetting(String keyword, boolean saveWhenPresent) {
        return keywordSettings.containsKey(keyword) && keywordSettings.get(keyword) != saveWhenPresent;
    }

    public void clearAllKeywords() {
        keywordSettings.clear();
    }

    // New setter for the includeFullScreenshot switch
    public void setIncludeFullScreenshot(boolean includeFullScreenshot) {
        this.includeFullScreenshot = includeFullScreenshot;
    }
}
