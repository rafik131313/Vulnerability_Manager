package com.BrupExtensionProject.burp_extension;

import org.knowm.xchart.*;
import org.knowm.xchart.internal.chartpart.Chart;
import org.knowm.xchart.style.Styler;
import org.jdatepicker.impl.JDatePanelImpl;
import org.jdatepicker.impl.JDatePickerImpl;
import org.jdatepicker.impl.UtilDateModel;

import org.knowm.xchart.XYChart;
import org.knowm.xchart.XYChartBuilder;
import org.knowm.xchart.style.markers.SeriesMarkers;

import burp.IBurpExtenderCallbacks;

import org.knowm.xchart.XYSeries;
import org.knowm.xchart.XYSeries.XYSeriesRenderStyle;

import java.awt.Color;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.stream.Collectors;

import javax.swing.*;
import java.awt.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.List;
import java.util.stream.Collectors;

public class XChartDashboard {
	private static IBurpExtenderCallbacks callbacks;
    private List<VulnerabilityStats> vulnerabilities;
    private Map<String, Integer> cipherSuitesCount;
    private String host;
    private XYChart lineChart;
    private JPanel chartPanel;
    
    public static void setCallbacks(IBurpExtenderCallbacks callbacks) {
        XChartDashboard.callbacks = callbacks;
    }

    public XChartDashboard(List<VulnerabilityStats> vulnerabilities, Map<String, Integer> cipherSuitesCount, String host) {
        this.vulnerabilities = vulnerabilities;
        this.cipherSuitesCount = cipherSuitesCount;
        this.host = host;
    }

    public JPanel createChartPanel() {
        JPanel mainPanel = new JPanel(new BorderLayout());

        String[] chartOptions = {"Vulnerabilities by risk level", 
        		"Vulnerabilities by Type and Severity", 
        		"Vulnerability trend over time", 
        		"SSL/TLS Configuration for scanned host", 
        		"Risk level distribution", 
        		"Vulnerabilities by host and severity", 
        		"Combined Charts"};
        JComboBox<String> chartSelector = new JComboBox<>(chartOptions);

        chartPanel = new JPanel(new BorderLayout());

        chartSelector.addActionListener(e -> {
            String selectedChart = (String) chartSelector.getSelectedItem();
            chartPanel.removeAll();
            if (selectedChart != null) {
                switch (selectedChart) {
                    case "Vulnerabilities by risk level":
                        chartPanel.add(vulnerabilities.isEmpty() ? createPlaceholderPanel("No vulnerabilities added yet.") : new XChartPanel<>(createPieChart()), BorderLayout.CENTER);
                        break;
                    case "Vulnerabilities by Type and Severity":
                        chartPanel.add(vulnerabilities.isEmpty() ? createPlaceholderPanel("No vulnerabilities added yet.") : new XChartPanel<>(createBarChart(false)), BorderLayout.CENTER);
                        break;
                    case "Vulnerability trend over time":
                        chartPanel.add(vulnerabilities.isEmpty() ? createPlaceholderPanel("No vulnerabilities added yet.") : createLineChartPanel(), BorderLayout.CENTER);
                        break;
                    case "SSL/TLS Configuration for scanned host":
                        chartPanel.add(isCipherSuitesDataEmpty() ? createPlaceholderPanel("No scan performed yet.") : createCipherSuitesPieChart(false), BorderLayout.CENTER);
                        break;
                    case "Risk level distribution":
                        chartPanel.add(vulnerabilities.isEmpty() ? createPlaceholderPanel("No vulnerabilities added yet.") : new XChartPanel<>(createHistogram()), BorderLayout.CENTER);
                        break;
                    case "Vulnerabilities by host and severity":
                        chartPanel.add(vulnerabilities.isEmpty() ? createPlaceholderPanel("No vulnerabilities added yet.") : new XChartPanel<>(createHostVulnerabilityChart(false)), BorderLayout.CENTER);
                        break;
                    case "Combined Charts":
                        chartPanel.add(createAllChartsPanel(), BorderLayout.CENTER);
                        break;
                }
                chartPanel.revalidate();
                chartPanel.repaint();
            }
        });

        mainPanel.add(chartSelector, BorderLayout.NORTH);
        mainPanel.add(chartPanel, BorderLayout.CENTER);

        chartSelector.setSelectedIndex(0);

        return mainPanel;
    }

    private JPanel createPlaceholderPanel(String message) {
        JPanel panel = new JPanel();
        panel.setLayout(new GridBagLayout());
        JLabel label = new JLabel(message);
        label.setFont(new Font("Arial", Font.BOLD, 20));
        panel.add(label, new GridBagConstraints());
        return panel;
    }

    private JPanel createAllChartsPanel() {
        JPanel charts = new JPanel(new GridLayout(2, 3));

        if (vulnerabilities.isEmpty()) {
            JPanel placeholder = createPlaceholderPanel("No vulnerabilities added yet.");
            charts.add(placeholder);
            charts.add(placeholder);
            charts.add(placeholder);
            charts.add(placeholder);
            charts.add(placeholder);
            charts.add(placeholder);
        } else {
            charts.add(new XChartPanel<>(createPieChart()));
            charts.add(new XChartPanel<>(createBarChart(true)));
            charts.add(new XChartPanel<>(createLineChart()));
            charts.add(isCipherSuitesDataEmpty() ? createPlaceholderPanel("No scan performed yet.") : createCipherSuitesPieChart(true));
            charts.add(new XChartPanel<>(createHistogram()));
            charts.add(new XChartPanel<>(createHostVulnerabilityChart(true)));
        }

        return charts;
    }

    private boolean isCipherSuitesDataEmpty() {
        return cipherSuitesCount == null || cipherSuitesCount.isEmpty();
    }

    private JPanel createCipherSuitesPieChart(boolean isForAllCharts) {
        Logger.log("[XChartDashboard]:Status cipherSuitesCount " + cipherSuitesCount);
        if (cipherSuitesCount == null) {
            return createPlaceholderPanel("No scan performed yet.");
        }

        PieChart chart = new PieChartBuilder().width(400).height(300).title("SSL/TLS Configuration for host: " + host).build();

        chart.addSeries("Recommended", cipherSuitesCount.getOrDefault("recommended", 0));
        chart.addSeries("Secure", cipherSuitesCount.getOrDefault("secure", 0));
        chart.addSeries("Weak", cipherSuitesCount.getOrDefault("weak", 0));
        chart.addSeries("Insecure", cipherSuitesCount.getOrDefault("insecure", 0));

        Color[] sliceColors = new Color[]{
            new Color(144, 238, 144),
            new Color(0, 100, 0),
            new Color(255, 165, 0),
            new Color(255, 0, 0)
        };
        chart.getStyler().setSeriesColors(sliceColors);

        JPanel panel = new JPanel();
        panel.setLayout(new BorderLayout());
        panel.add(new XChartPanel<>(chart), BorderLayout.CENTER);
        

        Logger.log("[XChartDashboard]:Status isForAllCharts " + isForAllCharts);
        

        if (!isForAllCharts) {
            JPanel suitesPanel = new JPanel(new BorderLayout());
            suitesPanel.setPreferredSize(new Dimension(550, 400));
            suitesPanel.setBorder(BorderFactory.createEmptyBorder(200, 50, 200, 50));
            suitesPanel.setBackground(new Color(210, 210, 210));

            JEditorPane suitesEditorPane = new JEditorPane();
            suitesEditorPane.setContentType("text/html");
            suitesEditorPane.setEditable(false);
            suitesEditorPane.setBackground(Color.WHITE);
            

            Logger.log("[XChartDashboard]SSLyzeScan.getScanOutput: " + SSLyzeScan.getScanOutput());

            String sortedScanOutput = sortCipherSuitesWithColors(SSLyzeScan.getScanOutput());
            Logger.log("[XChartDashboard]Sorted scan output: " + sortedScanOutput);
            suitesEditorPane.setText(sortedScanOutput);

            JScrollPane scrollPane = new JScrollPane(suitesEditorPane);
            suitesPanel.add(scrollPane, BorderLayout.CENTER);

            panel.add(suitesPanel, BorderLayout.EAST);
        }

        return panel;
    }



    private String sortCipherSuitesWithColors(String scanOutput) {
        Set<String> seenCipherSuites = new HashSet<>();
        List<String> recommended = new ArrayList<>();
        List<String> secure = new ArrayList<>();
        List<String> weak = new ArrayList<>();
        List<String> insecure = new ArrayList<>();

        String[] lines = scanOutput.split("\n");
        for (String line : lines) {
            String cipherSuite = line.substring(0, line.lastIndexOf(":")).trim();
            if (seenCipherSuites.add(cipherSuite)) {
                if (line.endsWith(": recommended")) {
                    recommended.add("<span style='color: black;'>" + cipherSuite + "</span><span style='color: black;'>:</span><span style='color: #90EE90; font-weight: bold;'> recommended</span>");
                } else if (line.endsWith(": secure")) {
                    secure.add("<span style='color: black;'>" + cipherSuite + "</span><span style='color: black;'>:</span><span style='color: #006400; font-weight: bold;'> secure</span>");
                } else if (line.endsWith(": weak")) {
                    weak.add("<span style='color: black;'>" + cipherSuite + "</span><span style='color: black;'>:</span><span style='color: #FFA500; font-weight: bold;'> weak</span>");
                } else if (line.endsWith(": insecure")) {
                    insecure.add("<span style='color: black;'>" + cipherSuite + "</span><span style='color: black;'>:</span><span style='color: #FF0000; font-weight: bold;'> insecure</span>");
                }
            }
        }

        StringBuilder sortedOutput = new StringBuilder();
        sortedOutput.append("<html><body>");
        recommended.forEach(line -> sortedOutput.append(line).append("<br>"));
        secure.forEach(line -> sortedOutput.append(line).append("<br>"));
        weak.forEach(line -> sortedOutput.append(line).append("<br>"));
        insecure.forEach(line -> sortedOutput.append(line).append("<br>"));
        sortedOutput.append("</body></html>");
        
        Logger.log("[XChartDashboard]SortedOutput " + sortedOutput.toString());

        return sortedOutput.toString();
    }


    private JPanel createLineChartPanel() {
        JPanel lineChartPanel = new JPanel(new BorderLayout());

        lineChart = createLineChart();
        XChartPanel<XYChart> chartPanel = new XChartPanel<>(lineChart);

        JPanel datePanel = new JPanel();
        JDatePickerImpl datePickerFrom = createDatePicker();
        JDatePickerImpl datePickerTo = createDatePicker();

        JButton updateButton = new JButton("Update");
        updateButton.addActionListener(e -> {
            Date fromDate = (Date) datePickerFrom.getModel().getValue();
            Date toDate = (Date) datePickerTo.getModel().getValue();
            updateLineChart(fromDate, toDate);
        });

        JButton resetButton = new JButton("Reset");
        resetButton.addActionListener(e -> {
            datePickerFrom.getModel().setValue(null);
            datePickerTo.getModel().setValue(null);
            updateLineChart(null, null);
        });

        datePanel.add(new JLabel("From:"));
        datePanel.add(datePickerFrom);
        datePanel.add(new JLabel("To:"));
        datePanel.add(datePickerTo);
        datePanel.add(updateButton);
        datePanel.add(resetButton);

        lineChartPanel.add(datePanel, BorderLayout.NORTH);
        lineChartPanel.add(chartPanel, BorderLayout.CENTER);

        return lineChartPanel;
    }


    private PieChart createPieChart() {
        PieChart chart = new PieChartBuilder().width(400).height(300).title("Vulnerabilities by Risk Level").build();

        List<String> riskLevels = Arrays.asList("Critical", "High", "Medium", "Low", "Information");

        Map<String, Integer> riskLevelCount = new HashMap<>();
        for (VulnerabilityStats v : vulnerabilities) {
            if (!v.isHostHeader()) {
                riskLevelCount.put(v.getRiskLevel(), riskLevelCount.getOrDefault(v.getRiskLevel(), 0) + 1);
            }
        }
        for (String riskLevel : riskLevels) {
            chart.addSeries(riskLevel, riskLevelCount.getOrDefault(riskLevel, 0));
        }

        setRiskLevelColors(chart);
        return chart;
    }

    private void setRiskLevelColors(PieChart chart) {
        Color[] sliceColors = {
                new Color(255, 0, 0), 
                new Color(255, 102, 102), 
                new Color(255, 165, 0), 
                new Color(0, 0, 255), 
                new Color(173, 216, 230)
        };

        chart.getStyler().setSeriesColors(sliceColors);
    }


    private CategoryChart createBarChart(boolean isForAllCharts) {
        CategoryChart chart = new CategoryChartBuilder().width(800).height(600).title("Vulnerabilities by Type and Severity").xAxisTitle("Type").yAxisTitle("Count").build();

        Map<String, Map<String, Long>> typeSeverityCount = vulnerabilities.stream()
                .filter(v -> !v.isHostHeader())
                .collect(Collectors.groupingBy(VulnerabilityStats::getVulnerabilityType,
                        Collectors.groupingBy(VulnerabilityStats::getRiskLevel, Collectors.counting())));

        Map<String, Integer> severityRanking = Map.of(
                "Critical", 4,
                "High", 3,
                "Medium", 2,
                "Low", 1,
                "Information", 0
        );

        List<Map.Entry<String, Map<String, Long>>> sortedEntries = typeSeverityCount.entrySet().stream()
                .sorted((e1, e2) -> {
                    int maxSeverityComparison = Integer.compare(
                            getMaxSeverity(e2.getValue(), severityRanking),
                            getMaxSeverity(e1.getValue(), severityRanking)
                    );
                    if (maxSeverityComparison != 0) {
                        return maxSeverityComparison;
                    }
                    return Long.compare(
                            getTotalCount(e2.getValue()),
                            getTotalCount(e1.getValue())
                    );
                })
                .collect(Collectors.toList());

        List<String> sortedCategories = sortedEntries.stream()
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());

        chart.getStyler().setLegendPosition(Styler.LegendPosition.OutsideE);
        chart.getStyler().setStacked(true);
        chart.getStyler().setHasAnnotations(!isForAllCharts);

        if (isForAllCharts) {
            chart.getStyler().setXAxisLabelRotation(60);
            chart.getStyler().setXAxisTickMarkSpacingHint(40);
            chart.getStyler().setHasAnnotations(false);
        } else {
            chart.getStyler().setXAxisLabelRotation(0);
            chart.getStyler().setXAxisTickMarkSpacingHint(5);
            chart.getStyler().setHasAnnotations(false);
        }

        for (String severity : Arrays.asList("Critical", "High", "Medium", "Low", "Information")) {
            List<Number> values = new ArrayList<>();
            for (String type : sortedCategories) {
                long count = typeSeverityCount.getOrDefault(type, Collections.emptyMap()).getOrDefault(severity, 0L);
                values.add(count);
            }
            chart.addSeries(severity, sortedCategories, values);
        }

        setRiskLevelColors(chart);
        
        chart.getStyler().setYAxisDecimalPattern("#");
        chart.getStyler().setYAxisTickMarkSpacingHint(1);
        
        return chart;
    }

    private int getMaxSeverity(Map<String, Long> severityCounts, Map<String, Integer> severityRanking) {
        return severityCounts.keySet().stream()
                .map(severityRanking::get)
                .max(Integer::compareTo)
                .orElse(0);
    }

    private long getTotalCount(Map<String, Long> severityCounts) {
        return severityCounts.values().stream()
                .mapToLong(Long::longValue)
                .sum();
    }




    private XYChart createLineChart() {
        XYChart lineChart = new XYChartBuilder().width(800).height(600).title("Vulnerability Trend Over Time").xAxisTitle("Time").yAxisTitle("Count").build();

        lineChart.getStyler().setYAxisDecimalPattern("#");
        lineChart.getStyler().setDatePattern("yyyy-MM-dd");

        Map<Date, Map<String, Long>> dateSeverityCount = vulnerabilities.stream()
                .filter(v -> !v.isHostHeader())
                .collect(Collectors.groupingBy(v -> {
                    try {
                        SimpleDateFormat originalFormat = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z", Locale.ENGLISH);
                        Date originalDate = originalFormat.parse(v.getDiscoveryTime());
                        Calendar cal = Calendar.getInstance();
                        cal.setTime(originalDate);
                        cal.set(Calendar.HOUR_OF_DAY, 0);
                        cal.set(Calendar.MINUTE, 0);
                        cal.set(Calendar.SECOND, 0);
                        cal.set(Calendar.MILLISECOND, 0);
                        return cal.getTime();
                    } catch (ParseException e) {
                        return new Date(0);
                    }
                }, TreeMap::new, Collectors.groupingBy(VulnerabilityStats::getRiskLevel, Collectors.counting())));

        if (dateSeverityCount.isEmpty()) {
            lineChart.addSeries("Vulnerability Count", new double[]{0}, new double[]{0});
        } else {
            List<Date> dates = new ArrayList<>(dateSeverityCount.keySet());
            List<Long> counts = dates.stream()
                    .map(date -> dateSeverityCount.get(date).values().stream().mapToLong(Long::longValue).sum())
                    .collect(Collectors.toList());

            XYSeries lineSeries = lineChart.addSeries("Vulnerability Count", dates, counts);
            lineSeries.setXYSeriesRenderStyle(XYSeriesRenderStyle.Line);
            lineSeries.setMarker(SeriesMarkers.NONE);
            lineSeries.setLineColor(Color.BLACK);

            Map<String, Color> severityColors = Map.of(
                    "Critical", new Color(255, 0, 0),
                    "High", new Color(255, 102, 102),
                    "Medium", new Color(255, 165, 0),
                    "Low", new Color(0, 0, 255),
                    "Information", new Color(173, 216, 230)
            );

            Map<Color, List<Date>> coloredPoints = new HashMap<>();
            for (Date date : dates) {
                Color pointColor = getHighestSeverityColor(dateSeverityCount.get(date), severityColors);
                coloredPoints.computeIfAbsent(pointColor, k -> new ArrayList<>()).add(date);
            }

            Map<Color, String> colorToSeverity = severityColors.entrySet().stream()
                    .collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));
            
            List<String> severityOrder = Arrays.asList("Critical", "High", "Medium", "Low", "Information");
            
            for (String severity : severityOrder) {
                Color severityColor = severityColors.get(severity);
                if (coloredPoints.containsKey(severityColor)) {
                    List<Date> colorDates = coloredPoints.get(severityColor);
                    List<Long> colorCounts = colorDates.stream()
                            .map(date -> dateSeverityCount.get(date).values().stream().mapToLong(Long::longValue).sum())
                            .collect(Collectors.toList());
                    XYSeries colorSeries = lineChart.addSeries(severity + " Severity", colorDates, colorCounts);
                    colorSeries.setXYSeriesRenderStyle(XYSeriesRenderStyle.Scatter);
                    colorSeries.setMarker(SeriesMarkers.CIRCLE);
                    lineChart.getStyler().setMarkerSize(12);
                    colorSeries.setLineColor(new Color(0, 0, 0, 0));
                    colorSeries.setMarkerColor(severityColor);
                }
            }
        }

        return lineChart;
    }

    private Color getHighestSeverityColor(Map<String, Long> severityCounts, Map<String, Color> severityColors) {
        List<String> severityOrder = Arrays.asList("Critical", "High", "Medium", "Low", "Information");
        for (String severity : severityOrder) {
            if (severityCounts.containsKey(severity)) {
                return severityColors.get(severity);
            }
        }
        return Color.BLACK;
    }
    
    
    
    private void updateLineChart(Date fromDate, Date toDate) {
        if (lineChart != null) {
            lineChart.getSeriesMap().clear();
            Map<Date, Map<String, Long>> dateSeverityCount = vulnerabilities.stream()
                    .filter(v -> !v.isHostHeader())
                    .filter(v -> {
                        try {
                            Date discoveryDate = new SimpleDateFormat("EEE, dd MMM yyyy", Locale.ENGLISH).parse(v.getDiscoveryTime());
                            return (fromDate == null || !discoveryDate.before(fromDate)) &&
                                   (toDate == null || !discoveryDate.after(toDate));
                        } catch (ParseException e) {
                            return false;
                        }
                    })
                    .collect(Collectors.groupingBy(v -> {
                        try {
                            SimpleDateFormat originalFormat = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z", Locale.ENGLISH);
                            Date originalDate = originalFormat.parse(v.getDiscoveryTime());
                            Calendar cal = Calendar.getInstance();
                            cal.setTime(originalDate);
                            cal.set(Calendar.HOUR_OF_DAY, 0);
                            cal.set(Calendar.MINUTE, 0);
                            cal.set(Calendar.SECOND, 0);
                            cal.set(Calendar.MILLISECOND, 0);
                            return cal.getTime();
                        } catch (ParseException e) {
                            return new Date(0);
                        }
                    }, TreeMap::new, Collectors.groupingBy(VulnerabilityStats::getRiskLevel, Collectors.counting())));

            if (dateSeverityCount.isEmpty()) {
                lineChart.addSeries("Vulnerability Count", new double[]{0}, new double[]{0});
            } else {
                List<Date> dates = new ArrayList<>(dateSeverityCount.keySet());
                List<Long> counts = dates.stream()
                        .map(date -> dateSeverityCount.get(date).values().stream().mapToLong(Long::longValue).sum())
                        .collect(Collectors.toList());

                XYSeries lineSeries = lineChart.addSeries("Vulnerability Count", dates, counts);
                lineSeries.setXYSeriesRenderStyle(XYSeriesRenderStyle.Line);
                lineSeries.setMarker(SeriesMarkers.NONE);
                lineSeries.setLineColor(Color.BLACK);

                Map<String, Color> severityColors = Map.of(
                        "Critical", new Color(255, 0, 0),
                        "High", new Color(255, 102, 102),
                        "Medium", new Color(255, 165, 0),
                        "Low", new Color(0, 0, 255),
                        "Information", new Color(173, 216, 230)
                );

                Map<Color, List<Date>> coloredPoints = new HashMap<>();
                for (Date date : dates) {
                    Color pointColor = getHighestSeverityColor(dateSeverityCount.get(date), severityColors);
                    coloredPoints.computeIfAbsent(pointColor, k -> new ArrayList<>()).add(date);
                }

                Map<Color, String> colorToSeverity = severityColors.entrySet().stream()
                        .collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));
                
                List<String> severityOrder = Arrays.asList("Critical", "High", "Medium", "Low", "Information");
                
                for (String severity : severityOrder) {
                    Color severityColor = severityColors.get(severity);
                    if (coloredPoints.containsKey(severityColor)) {
                        List<Date> colorDates = coloredPoints.get(severityColor);
                        List<Long> colorCounts = colorDates.stream()
                                .map(date -> dateSeverityCount.get(date).values().stream().mapToLong(Long::longValue).sum())
                                .collect(Collectors.toList());
                        XYSeries colorSeries = lineChart.addSeries(severity + " Severity", colorDates, colorCounts);
                        colorSeries.setXYSeriesRenderStyle(XYSeriesRenderStyle.Scatter);
                        colorSeries.setMarker(SeriesMarkers.CIRCLE);
                        lineChart.getStyler().setMarkerSize(12);
                        colorSeries.setLineColor(new Color(0, 0, 0, 0));
                        colorSeries.setMarkerColor(severityColor);
                    }
                }
            }

            lineChart.getStyler().setDatePattern("yyyy-MM-dd");

            chartPanel.revalidate();
            chartPanel.repaint();
        }
    }

    private CategoryChart createHistogram() {
        CategoryChart chart = new CategoryChartBuilder().width(400).height(300).title("Risk Level Distribution").xAxisTitle("Risk Level").yAxisTitle("Count").build();

        Map<String, Long> riskLevelCount = vulnerabilities.stream()
                .filter(v -> !v.isHostHeader())
                .collect(Collectors.groupingBy(VulnerabilityStats::getRiskLevel, Collectors.counting()));

        chart.getStyler().setLegendVisible(true);
        chart.getStyler().setHasAnnotations(true);
        chart.getStyler().setYAxisMin(0.0);
        chart.getStyler().setYAxisDecimalPattern("#");
        chart.getStyler().setXAxisLabelRotation(0);

        Map<String, Color> riskLevelColors = Map.of(
                "Critical", new Color(255, 0, 0),
                "High", new Color(255, 102, 102),
                "Medium", new Color(255, 165, 0),
                "Low", new Color(0, 0, 255),
                "Information", new Color(173, 216, 230)
        );

        List<String> riskLevels = Arrays.asList("Critical", "High", "Medium", "Low", "Information");

        for (String riskLevel : riskLevels) {
            if (riskLevelCount.containsKey(riskLevel)) {
                chart.addSeries(riskLevel, Collections.singletonList(riskLevel), Collections.singletonList(riskLevelCount.get(riskLevel)))
                     .setFillColor(riskLevelColors.get(riskLevel));
            }
        }

        return chart;
    }


    private CategoryChart createHostVulnerabilityChart(boolean isForAllCharts) {
        CategoryChart chart = new CategoryChartBuilder().width(800).height(600).title("Vulnerabilities by Host and Severity").xAxisTitle("Host").yAxisTitle("Count").build();

        Map<String, Map<String, Long>> hostSeverityCount = vulnerabilities.stream()
                .filter(v -> !v.isHostHeader())
                .collect(Collectors.groupingBy(v -> v.getUrl().getHost(),
                        Collectors.groupingBy(VulnerabilityStats::getRiskLevel, Collectors.counting())));

        Map<String, Integer> severityRanking = Map.of(
                "Critical", 4,
                "High", 3,
                "Medium", 2,
                "Low", 1,
                "Information", 0
        );

        List<Map.Entry<String, Map<String, Long>>> sortedEntries = hostSeverityCount.entrySet().stream()
                .sorted((e1, e2) -> {
                    int maxSeverityComparison = Integer.compare(
                            getMaxSeverity(e2.getValue(), severityRanking),
                            getMaxSeverity(e1.getValue(), severityRanking)
                    );
                    if (maxSeverityComparison != 0) {
                        return maxSeverityComparison;
                    }
                    return Long.compare(
                            getTotalCount(e2.getValue()),
                            getTotalCount(e1.getValue())
                    );
                })
                .collect(Collectors.toList());

        List<String> sortedHosts = sortedEntries.stream()
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());

        chart.getStyler().setLegendPosition(Styler.LegendPosition.OutsideE);
        chart.getStyler().setStacked(true);
        chart.getStyler().setHasAnnotations(false);

        if (isForAllCharts) {
            chart.getStyler().setXAxisLabelRotation(60);
            chart.getStyler().setXAxisTickMarkSpacingHint(40);
        } else {
            chart.getStyler().setXAxisLabelRotation(0);
            chart.getStyler().setXAxisTickMarkSpacingHint(5);
        }

        for (String severity : Arrays.asList("Critical", "High", "Medium", "Low", "Information")) {
            List<Number> values = new ArrayList<>();
            for (String host : sortedHosts) {
                long count = hostSeverityCount.getOrDefault(host, Collections.emptyMap()).getOrDefault(severity, 0L);
                values.add(count);
            }
            chart.addSeries(severity, sortedHosts, values);
        }

        setRiskLevelColors(chart);
        return chart;
    }



    private void setRiskLevelColors(CategoryChart chart, List<String> riskLevels) {
        Map<String, Color> riskLevelColors = new HashMap<>();
        riskLevelColors.put("Critical", new Color(255, 0, 0));
        riskLevelColors.put("High", new Color(255, 102, 102));
        riskLevelColors.put("Medium", new Color(255, 165, 0));
        riskLevelColors.put("Low", new Color(0, 0, 255));
        riskLevelColors.put("Information", new Color(173, 216, 230));

        List<Color> seriesColors = new ArrayList<>();
        for (String riskLevel : riskLevels) {
            if (riskLevelColors.containsKey(riskLevel)) {
                seriesColors.add(riskLevelColors.get(riskLevel));
            }
        }

        if (!seriesColors.isEmpty()) {
            chart.getStyler().setSeriesColors(seriesColors.toArray(new Color[0]));
        }
    }

    private void setRiskLevelColors(CategoryChart chart) {
        Map<String, Color> riskLevelColors = new HashMap<>();
        riskLevelColors.put("Critical", new Color(255, 0, 0));
        riskLevelColors.put("High", new Color(255, 102, 102));
        riskLevelColors.put("Medium", new Color(255, 165, 0));
        riskLevelColors.put("Low", new Color(0, 0, 255));
        riskLevelColors.put("Information", new Color(173, 216, 230));

        int seriesIndex = 0;
        for (Map.Entry<String, Color> entry : riskLevelColors.entrySet()) {
            if (chart.getSeriesMap().containsKey(entry.getKey())) {
                chart.getSeriesMap().get(entry.getKey()).setFillColor(entry.getValue());
            }
            seriesIndex++;
        }
    }

    private void setRiskLevelColors(Chart<?, ?> chart) {
        Color[] sliceColors = {
                new Color(255, 0, 0),
                new Color(255, 102, 102),
                new Color(255, 165, 0),
                new Color(0, 0, 255),
                new Color(173, 216, 230)
        };

        Map<String, Color> riskLevelColorMap = new HashMap<>();
        riskLevelColorMap.put("Critical", sliceColors[0]);
        riskLevelColorMap.put("High", sliceColors[1]);
        riskLevelColorMap.put("Medium", sliceColors[2]);
        riskLevelColorMap.put("Low", sliceColors[3]);
        riskLevelColorMap.put("Info", sliceColors[4]);

        List<Color> seriesColors = new ArrayList<>();
        for (String seriesName : chart.getSeriesMap().keySet()) {
            for (String riskLevel : riskLevelColorMap.keySet()) {
                if (seriesName.contains(riskLevel)) {
                    seriesColors.add(riskLevelColorMap.get(riskLevel));
                }
            }
        }

        if (!seriesColors.isEmpty()) {
            chart.getStyler().setSeriesColors(seriesColors.toArray(new Color[0]));
        }
    }

    private JDatePickerImpl createDatePicker() {
        UtilDateModel model = new UtilDateModel();
        Properties p = new Properties();
        p.put("text.today", "Today");
        p.put("text.month", "Month");
        p.put("text.year", "Year");
        JDatePanelImpl datePanel = new JDatePanelImpl(model, p);
        return new JDatePickerImpl(datePanel, new DateLabelFormatter());
    }

    public class DateLabelFormatter extends JFormattedTextField.AbstractFormatter {
        private String datePattern = "yyyy-MM-dd";
        private SimpleDateFormat dateFormatter = new SimpleDateFormat(datePattern);

        @Override
        public Object stringToValue(String text) throws ParseException {
            return dateFormatter.parseObject(text);
        }

        @Override
        public String valueToString(Object value) throws ParseException {
            if (value != null) {
                Calendar cal = (Calendar) value;
                return dateFormatter.format(cal.getTime());
            }
            return "";
        }
    }
}
