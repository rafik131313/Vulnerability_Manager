package com.BrupExtensionProject.burp_extension;

import javax.swing.table.AbstractTableModel;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

public class VulnerabilitiesTableModel extends AbstractTableModel {
    private final String[] columnNames = {"Type", "Risk Level", "URL", "Discovery Time"};
    private List<VulnerabilityStats> vulnerabilityStats;

    public VulnerabilitiesTableModel(List<VulnerabilityStats> vulnerabilityStats) {
        this.vulnerabilityStats = vulnerabilityStats;
    }

    @Override
    public int getRowCount() {
        return vulnerabilityStats.size();
    }

    @Override
    public int getColumnCount() {
        return columnNames.length;
    }

    @Override
    public String getColumnName(int columnIndex) {
        return columnNames[columnIndex];
    }

    @Override
    public Object getValueAt(int rowIndex, int columnIndex) {
        VulnerabilityStats stats = vulnerabilityStats.get(rowIndex);
        System.out.println("Rendering value at row " + rowIndex + ", column " + columnIndex + ": " + stats);
        switch (columnIndex) {
            case 0: return stats.getVulnerabilityType();
            case 1: return stats.getRiskLevel();
            case 2: return stats.getUrl() != null ? stats.getUrl().toString() : "";
            case 3: return stats.getDiscoveryTime();
            default: return null;
        }
    }

    public void sortByRiskLevel() {
        List<VulnerabilityStats> sortedStats = new ArrayList<>();
        String currentHost = null;
        List<VulnerabilityStats> currentHostStats = new ArrayList<>();

        for (VulnerabilityStats stat : vulnerabilityStats) {
            if (stat.isHostHeader()) {
                if (!currentHostStats.isEmpty()) {
                    currentHostStats.sort(new Comparator<VulnerabilityStats>() {
                        @Override
                        public int compare(VulnerabilityStats o1, VulnerabilityStats o2) {
                            return riskLevelToInt(o2.getRiskLevel()) - riskLevelToInt(o1.getRiskLevel());
                        }

                        private int riskLevelToInt(String riskLevel) {
                            switch (riskLevel) {
                                case "High": return 3;
                                case "Medium": return 2;
                                case "Low": return 1;
                                default: return 0;
                            }
                        }
                    });
                    sortedStats.addAll(currentHostStats);
                    currentHostStats.clear();
                }
                sortedStats.add(stat);
                currentHost = stat.getVulnerabilityType();
            } else {
                currentHostStats.add(stat);
            }
        }

        if (!currentHostStats.isEmpty()) {
            currentHostStats.sort(new Comparator<VulnerabilityStats>() {
                @Override
                public int compare(VulnerabilityStats o1, VulnerabilityStats o2) {
                    return riskLevelToInt(o2.getRiskLevel()) - riskLevelToInt(o1.getRiskLevel());
                }

                private int riskLevelToInt(String riskLevel) {
                    switch (riskLevel) {
                        case "High": return 3;
                        case "Medium": return 2;
                        case "Low": return 1;
                        default: return 0;
                    }
                }
            });
            sortedStats.addAll(currentHostStats);
        }

        this.vulnerabilityStats = sortedStats;
        fireTableDataChanged();
    }

    public void addVulnerability(VulnerabilityStats vulnerability) {
        vulnerabilityStats.add(vulnerability);
        fireTableRowsInserted(vulnerabilityStats.size() - 1, vulnerabilityStats.size() - 1);
    }
}
