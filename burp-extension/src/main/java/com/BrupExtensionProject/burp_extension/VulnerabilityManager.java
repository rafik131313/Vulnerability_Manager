package com.BrupExtensionProject.burp_extension;

import burp.IBurpExtenderCallbacks;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import org.jdatepicker.impl.JDatePanelImpl;
import org.jdatepicker.impl.JDatePickerImpl;
import org.jdatepicker.impl.UtilDateModel;

import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableCellRenderer;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.*;
import java.lang.reflect.Type;
import java.net.MalformedURLException;
import java.net.URL;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.List;
import java.awt.*;

public class VulnerabilityManager {
    private IBurpExtenderCallbacks callbacks;
    private UIComponents uiComponents;
    private List<VulnerabilityStats> vulnerabilityStats;
    private VulnerabilitiesTableModel tableModel;
    private Set<String> hosts;
    private JTable table;
    private boolean isLoading;
    private Map<String, Integer> cipherSuitesCount;

    public VulnerabilityManager(IBurpExtenderCallbacks callbacks, UIComponents uiComponents) {
        this.callbacks = callbacks;
        this.uiComponents = uiComponents;
        this.vulnerabilityStats = new ArrayList<>();
        this.tableModel = new VulnerabilitiesTableModel(vulnerabilityStats);
        this.hosts = new HashSet<>();
        this.isLoading = false;
        this.cipherSuitesCount = new HashMap<>();
    }
    
    public Set<String> getHosts() {
        return new HashSet<>(hosts);
    }
    
    public Map<String, Integer> getCipherSuitesCount() {
        return cipherSuitesCount;
    }
    
    public void updateCipherSuitesCount(Map<String, Integer> cipherSuitesCount) {
        if (cipherSuitesCount != null) {
            this.cipherSuitesCount = cipherSuitesCount;
            Logger.log("Updated cipher suites count: " + cipherSuitesCount);
            uiComponents.updateXChartDashboard(""); // Aktualizacja wykresu po zmianie wyników skanowania
            SSLyzeScan.saveScanResults(); // Zapisz wyniki skanowania po aktualizacji wyników
        }
    }

    public UIComponents getUIComponents() {
        return uiComponents;
    }

    
    private String scanOutput;

    public void setScanOutput(String scanOutput) {
        this.scanOutput = scanOutput;
    }

    public String getScanOutput() {
        return scanOutput;
    }

    public void loadVulnerabilities(List<VulnerabilityStats> savedVulnerabilities) {
        Logger.log("[VulnerabilityManager] loadVulnerabilities called");
        Logger.log("[VulnerabilityManager] Clearing existing vulnerabilities");
        isLoading = true; // Ustawienie flagi isLoading na true przed rozpoczęciem ładowania
        Logger.log("[VulnerabilityManager] Zmiana flagi isLoading na: " + isLoading);
        synchronized (vulnerabilityStats) {
            vulnerabilityStats.clear();
        }

        if (savedVulnerabilities != null) {
            for (VulnerabilityStats vulnerability : savedVulnerabilities) {
                Logger.log("[VulnerabilityManager] Adding vulnerability: " + vulnerability);
                addVulnerability(vulnerability, false);
                uiComponents.refreshTLSCheckerPanel();
                uiComponents.updateScanResultsList();
            }
        }

        SwingUtilities.invokeLater(() -> {
            tableModel.fireTableDataChanged();
            table.revalidate();
            table.repaint();
            isLoading = false; // Ustawienie flagi isLoading na false po zakończeniu ładowania
            Logger.log("[VulnerabilityManager] Zmiana flagi isLoading na: " + isLoading);
        });
    }
    
    
    
    public void clearAllVulnerabilities() {
        synchronized (vulnerabilityStats) {
            vulnerabilityStats.clear();
            hosts.clear();

            SwingUtilities.invokeLater(() -> {
                tableModel.fireTableDataChanged();
                table.revalidate();
                table.repaint();
            });

            uiComponents.updateXChartDashboard();

            if (!isLoading) {
                uiComponents.saveVulnerabilities();
            }
            
            SSLyzeScan.clearCipherSuites(); // Wyczyszczenie danych cipher suitów

            Logger.log("[VulnerabilityManager] All vulnerabilities and cipher suites cleared.");
        }
    }


    public JScrollPane createScrollPane() {
        table = new JTable(tableModel) {
            @Override
            public TableCellRenderer getCellRenderer(int row, int column) {
                if (vulnerabilityStats.get(row).isHostHeader()) {
                    return new HostHeaderRenderer();
                }
                return super.getCellRenderer(row, column);
            }
        };

        table.setDefaultRenderer(Object.class, new VulnerabilityTableCellRenderer());

        // Dodanie menu kontekstowego do tabeli
        JPopupMenu popupMenu = new JPopupMenu();
        JMenuItem removeItem = new JMenuItem("Remove");
        removeItem.addActionListener(e -> {
            int selectedRow = table.getSelectedRow();
            if (selectedRow != -1) {
                removeVulnerability(selectedRow);
                Logger.log("Removed vulnerability at index: " + selectedRow);
            }
        });
        popupMenu.add(removeItem);

        table.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    showPopup(e);
                }
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    showPopup(e);
                }
            }

            private void showPopup(MouseEvent e) {
                int row = table.rowAtPoint(e.getPoint());
                table.setRowSelectionInterval(row, row);
                popupMenu.show(e.getComponent(), e.getX(), e.getY());
            }
        });

        // Dodanie obsługi dwukrotnego kliknięcia
        table.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getClickCount() == 2 && table.getSelectedRow() != -1) {
                    openEditVulnerabilityDialog(table.getSelectedRow());
                }
            }
        });

        // Dodanie przycisku "Add"
        JButton addButton = new JButton("Add Vulnerability");
        addButton.addActionListener(e -> openAddVulnerabilityDialog());

        JPanel panel = new JPanel(new BorderLayout());
        panel.add(new JScrollPane(table), BorderLayout.CENTER);
        panel.add(addButton, BorderLayout.SOUTH);

        return new JScrollPane(panel);
    }

    private void openEditVulnerabilityDialog(int rowIndex) {
        VulnerabilityStats oldVulnerability = vulnerabilityStats.get(rowIndex);

        JTextField typeField = new JTextField(oldVulnerability.getVulnerabilityType());
        JComboBox<String> riskLevelField = new JComboBox<>(new String[]{"Information", "Low", "Medium", "High", "Critical"});
        riskLevelField.setSelectedItem(oldVulnerability.getRiskLevel());

        final JComponent[] inputs = new JComponent[]{
            new JLabel("Vulnerability Type"),
            typeField,
            new JLabel("Risk Level"),
            riskLevelField
        };

        int result = JOptionPane.showConfirmDialog(null, inputs, "Edit Vulnerability", JOptionPane.PLAIN_MESSAGE);
        if (result == JOptionPane.OK_OPTION) {
            VulnerabilityStats newVulnerability = new VulnerabilityStats(
                typeField.getText(),
                (String) riskLevelField.getSelectedItem(),
                oldVulnerability.getUrl(),
                oldVulnerability.getDiscoveryTime(),
                oldVulnerability.getRequest(),
                oldVulnerability.getResponse(),
                oldVulnerability.isHostHeader()
            );

            vulnerabilityStats.set(rowIndex, newVulnerability);

            tableModel.fireTableRowsUpdated(rowIndex, rowIndex);
            table.revalidate();
            table.repaint();
            
            uiComponents.updateXChartDashboard();
            
            if (!isLoading) { // Sprawdzenie flagi isLoading przed zapisaniem
                uiComponents.saveVulnerabilities();
            }
            

        }
    }

    private void openAddVulnerabilityDialog() {
        JTextField typeField = new JTextField();
        JComboBox<String> riskLevelField = new JComboBox<>(new String[]{"Information", "Low", "Medium", "High", "Critical"});
        JTextField urlField = new JTextField();

        UtilDateModel model = new UtilDateModel();
        Properties p = new Properties();
        p.put("text.today", "Today");
        p.put("text.month", "Month");
        p.put("text.year", "Year");
        JDatePanelImpl datePanel = new JDatePanelImpl(model, p);
        JDatePickerImpl datePicker = new JDatePickerImpl(datePanel, new DateLabelFormatter());

        JComboBox<String> hourField = new JComboBox<>();
        for (int i = 0; i < 24; i++) {
            hourField.addItem(String.format("%02d", i));
        }

        JComboBox<String> minuteField = new JComboBox<>();
        for (int i = 0; i < 60; i++) {
            minuteField.addItem(String.format("%02d", i));
        }

        JComboBox<String> timeZoneField = new JComboBox<>(new String[]{"CEST", "GMT", "PST", "EST"});
        timeZoneField.setSelectedItem("CEST");

        // Wczytanie listy podatności z pliku tekstowego
        List<String> vulnerabilities = loadVulnerabilitiesFromTextfile("/vulnerabilities.txt");
        JComboBox<String> vulnerabilityTypeField = new JComboBox<>(vulnerabilities.toArray(new String[0]));
        vulnerabilityTypeField.setEditable(true);

        final JComponent[] inputs = new JComponent[]{
                new JLabel("Vulnerability Type"),
                vulnerabilityTypeField,
                new JLabel("Risk Level"),
                riskLevelField,
                new JLabel("URL"),
                urlField,
                new JLabel("Discovery Date"),
                datePicker,
                new JLabel("Hour"),
                hourField,
                new JLabel("Minute"),
                minuteField,
                new JLabel("Time Zone"),
                timeZoneField
        };

        int result = JOptionPane.showConfirmDialog(null, inputs, "Add Vulnerability", JOptionPane.PLAIN_MESSAGE);
        if (result == JOptionPane.OK_OPTION) {
            try {
                String type = (String) vulnerabilityTypeField.getSelectedItem();
                String riskLevel = (String) riskLevelField.getSelectedItem();
                URL url = new URL(urlField.getText());

                Date selectedDate = (Date) datePicker.getModel().getValue();
                Calendar calendar = Calendar.getInstance();
                calendar.setTime(selectedDate);
                int hour = Integer.parseInt((String) hourField.getSelectedItem());
                int minute = Integer.parseInt((String) minuteField.getSelectedItem());

                calendar.set(Calendar.HOUR_OF_DAY, hour);
                calendar.set(Calendar.MINUTE, minute);

                String timeZone = (String) timeZoneField.getSelectedItem();
                TimeZone tz = TimeZone.getTimeZone(timeZone);
                calendar.setTimeZone(tz);

                SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z");
                sdf.setTimeZone(tz);
                String discoveryTime = sdf.format(calendar.getTime());

                // Logowanie wartości
                Logger.log("Adding vulnerability manually:");
                Logger.log("Type: " + type);
                Logger.log("Risk Level: " + riskLevel);
                Logger.log("URL: " + url);
                Logger.log("Discovery Time: " + discoveryTime);

                addVulnerability(new VulnerabilityStats(type, riskLevel, url, discoveryTime, "", "", false));
                
                if (!isLoading) { // Sprawdzenie flagi isLoading przed zapisaniem
                    uiComponents.saveVulnerabilities(); // Aktualizacja listy "Already scanned hosts"
                }
            } catch (MalformedURLException e) {
                callbacks.printError("Invalid URL format: " + urlField.getText());
                JOptionPane.showMessageDialog(null, "Invalid URL format.", "Error", JOptionPane.ERROR_MESSAGE);
            } catch (Exception e) {
                callbacks.printError("Error adding vulnerability: " + e.getMessage());
            }
        }
    }

    private boolean isDuplicateVulnerability(String vulnerabilityType, String riskLevel, URL url) {
        return vulnerabilityStats.stream().anyMatch(v -> 
            v.getVulnerabilityType().equals(vulnerabilityType) && 
            v.getRiskLevel().equals(riskLevel) && 
            v.getUrl().equals(url) && 
            !v.isHostHeader());
    }

    public void addVulnerability(VulnerabilityStats vulnerability) {
        addVulnerability(vulnerability, true);
        if (!isLoading) { // Sprawdzenie flagi isLoading przed zapisaniem
            uiComponents.saveVulnerabilities();
        }
        uiComponents.refreshTLSCheckerPanel();
        uiComponents.updateScanResultsList();
    }

    public void addVulnerability(VulnerabilityStats vulnerability, boolean updateTable) {
        synchronized (vulnerabilityStats) {
            Logger.log("[VulnerabilityManager] addVulnerability called with: " + vulnerability);
            if (isDuplicateVulnerability(vulnerability.getVulnerabilityType(), vulnerability.getRiskLevel(), vulnerability.getUrl())) {
                Logger.log("[VulnerabilityManager] Vulnerability already exists: " + vulnerability);
                JOptionPane.showMessageDialog(null, 
                        "Vulnerability already exists:\n" +
                        "Type: " + vulnerability.getVulnerabilityType() + "\n" +
                        "Risk Level: " + vulnerability.getRiskLevel() + "\n" +
                        "URL: " + vulnerability.getUrl(), 
                        "Duplicate Vulnerability", 
                        JOptionPane.INFORMATION_MESSAGE);
                return;
            }

            String host = vulnerability.getUrl() != null ? vulnerability.getUrl().getHost() : null;
            int insertIndex = vulnerabilityStats.size();

            boolean hostHeaderExists = false;
            for (int i = 0; i < vulnerabilityStats.size(); i++) {
                VulnerabilityStats stats = vulnerabilityStats.get(i);
                if (stats.isHostHeader() && stats.getVulnerabilityType().equals("Host: " + host)) {
                    hostHeaderExists = true;
                    insertIndex = i + 1;
                    while (insertIndex < vulnerabilityStats.size() && !vulnerabilityStats.get(insertIndex).isHostHeader()) {
                        insertIndex++;
                    }
                    break;
                }
            }

            if (!hostHeaderExists) {
                hosts.add(host);
                VulnerabilityStats hostHeader = new VulnerabilityStats("Host: " + host, "", null, "", "", "", true);
                vulnerabilityStats.add(insertIndex, hostHeader);
                if (updateTable) {
                    tableModel.fireTableRowsInserted(vulnerabilityStats.size() - 1, vulnerabilityStats.size() - 1);
                }
                insertIndex++;
            }

            vulnerabilityStats.add(insertIndex, vulnerability);
            if (updateTable) {
                tableModel.fireTableRowsInserted(insertIndex, insertIndex);
            }

            uiComponents.updateXChartDashboard();

            Logger.log("[VulnerabilityManager] Added vulnerability: " + vulnerability);

            if (updateTable) {
                SwingUtilities.invokeLater(() -> {
                    tableModel.fireTableDataChanged();
                    table.revalidate();
                    table.repaint();
                    uiComponents.updateScanResultsList();
                });
            }
        }
    }

    private List<String> loadVulnerabilitiesFromTextfile(String filePath) {
        List<String> vulnerabilities = new ArrayList<>();
        try (BufferedReader br = new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(filePath)))) {
            String line;
            while ((line = br.readLine()) != null) {
                vulnerabilities.add(line);
            }
            Logger.log("Loaded vulnerabilities from text file: " + vulnerabilities);
        } catch (IOException e) {
            callbacks.printError("Error reading vulnerabilities file: " + e.getMessage());
        } catch (NullPointerException e) {
            callbacks.printError("File not found: " + filePath);
        }
        return vulnerabilities;
    }

    public void removeVulnerability(int index) {
        synchronized (vulnerabilityStats) {
            if (index >= 0 && index < vulnerabilityStats.size()) {
                VulnerabilityStats removed = vulnerabilityStats.remove(index);
                tableModel.fireTableRowsDeleted(index, index);

                if (removed != null && !removed.isHostHeader()) {
                    String host = removed.getUrl().getHost();
                    boolean hasMoreVulnerabilities = vulnerabilityStats.stream()
                            .anyMatch(v -> !v.isHostHeader() && v.getUrl().getHost().equals(host));

                    if (!hasMoreVulnerabilities) {
                        vulnerabilityStats.removeIf(v -> v.isHostHeader() && v.getVulnerabilityType().equals("Host: " + host));
                        hosts.remove(host);
                    }
                }

                uiComponents.updateXChartDashboard();

                SwingUtilities.invokeLater(() -> {
                    tableModel.fireTableDataChanged();
                    table.revalidate();
                    table.repaint();
                });

                // Zapisz podatności po usunięciu
                if (!isLoading) { // Sprawdzenie flagi isLoading przed zapisaniem
                    uiComponents.saveVulnerabilities();
                }
                
                uiComponents.updateScanResultsList();
            }
        }
    }

    public List<VulnerabilityStats> getVulnerabilities() {
        return vulnerabilityStats;
    }

    // Renderer dla nagłówków hostów
    class HostHeaderRenderer extends DefaultTableCellRenderer {
        @Override
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
            JLabel label = (JLabel) super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
            label.setFont(label.getFont().deriveFont(Font.BOLD, 14f));
            label.setHorizontalAlignment(SwingConstants.CENTER);
            return label;
        }
    }

    // Renderer dla innych komórek tabeli
    class VulnerabilityTableCellRenderer extends DefaultTableCellRenderer {
        @Override
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
            Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
            if (vulnerabilityStats.get(row).isHostHeader()) {
                c.setFont(c.getFont().deriveFont(Font.BOLD, 14f));
                ((JLabel) c).setHorizontalAlignment(SwingConstants.CENTER);
            } else {
                c.setFont(c.getFont().deriveFont(Font.PLAIN, 12f));
                ((JLabel) c).setHorizontalAlignment(SwingConstants.LEFT);
            }
            return c;
        }
    }

    class DateLabelFormatter extends JFormattedTextField.AbstractFormatter {
        private String datePattern = "yyyy-MM-dd";
        private SimpleDateFormat dateFormatter = new SimpleDateFormat(datePattern);

        @Override
        public Object stringToValue(String text) throws ParseException {
            return dateFormatter.parseObject(text);
        }

        @Override
        public String valueToString(Object value) throws ParseException {
            if (value != null) {
                Calendar cal = (Calendar) value;
                return dateFormatter.format(cal.getTime());
            }

            return "";
        }
    }
}