package com.BrupExtensionProject.burp_extension;

import burp.IBurpExtenderCallbacks;

import java.io.*;
import java.lang.reflect.Type;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.function.Consumer;

import javax.swing.JOptionPane;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

public class SSLyzeScan {
    private static IBurpExtenderCallbacks callbacks;
    private static Set<String> cipherSuiteNames;
    private static Map<String, String> cipherSuiteDetails;
    private static String scanOutput;
    private static String lastScannedHost;
    private static final String SCAN_RESULTS_KEY = "scanResults";
    private static final String LAST_SCANNED_HOST_KEY = "lastScannedHost";
    private static final String RAW_SCAN_RESULTS_KEY = "rawScanResults";
    private static Map<String, String> rawScanResults = new HashMap<>();
    

    public static void setCallbacks(IBurpExtenderCallbacks callbacks) {
        SSLyzeScan.callbacks = callbacks;
    }

    public static void setCipherSuites(Set<String> cipherSuiteNames, Map<String, String> cipherSuiteDetails) {
        SSLyzeScan.cipherSuiteNames = cipherSuiteNames;
        SSLyzeScan.cipherSuiteDetails = cipherSuiteDetails;
    }
    
    public static Map<String, String> getCipherSuiteDetails() {
        return cipherSuiteDetails;
    }

    public static String getScanOutput() {
        return scanOutput;
    }
    
    public static Map<String, String> getRawScanResults() {
        return rawScanResults;
    }
    
    public static void saveScanResults() {
        Gson gson = new Gson();
        String scanOutputJson = gson.toJson(scanOutput);
        String rawScanResultsJson = gson.toJson(rawScanResults); // Dodane
        callbacks.saveExtensionSetting(SCAN_RESULTS_KEY, scanOutputJson);
        callbacks.saveExtensionSetting(RAW_SCAN_RESULTS_KEY, rawScanResultsJson); // Dodane
        saveLastScannedHost(); // Zapisz nazwę ostatnio skanowanego hosta
    }
    
    public static void clearRawScanResults() {
        rawScanResults.clear(); // Wyczyszczenie surowych wyników skanowania
        scanOutput = ""; // Dodane, aby wyczyścić scanOutput
        saveScanResults(); // Zapisanie zmian
        Logger.log("Cleared all raw scan results.");
    }


    public static void loadScanResults() {
        Gson gson = new Gson();
        String scanOutputJson = callbacks.loadExtensionSetting(SCAN_RESULTS_KEY);
        String rawScanResultsJson = callbacks.loadExtensionSetting(RAW_SCAN_RESULTS_KEY); // Dodane
        if (scanOutputJson != null && !scanOutputJson.isEmpty()) {
            scanOutput = gson.fromJson(scanOutputJson, String.class);
        }
        if (rawScanResultsJson != null && !rawScanResultsJson.isEmpty()) { // Dodane
            Type type = new TypeToken<Map<String, String>>() {}.getType(); // Dodane
            rawScanResults = gson.fromJson(rawScanResultsJson, type); // Dodane
        }
        loadLastScannedHost(); // Wczytaj nazwę ostatnio skanowanego hosta
    }
    
    public static void saveLastScannedHost() {
        if (lastScannedHost != null) {
            callbacks.saveExtensionSetting(LAST_SCANNED_HOST_KEY, lastScannedHost);
        }
    }

    public static void loadLastScannedHost() {
        lastScannedHost = callbacks.loadExtensionSetting(LAST_SCANNED_HOST_KEY);
    }
    
    public static String getLastScannedHost() {
        return lastScannedHost; // Getter dla lastScannedHost
    }

    public static String runSSLyzeScan(String host) {
        lastScannedHost = host; // Przypisz nazwę hosta do zmiennej lastScannedHost
        StringBuilder output = new StringBuilder();
        File outputFile = new File("sslyze_output.txt");

        try {
            Logger.log("Starting SSLyze scan for host: " + host);
            ProcessBuilder processBuilder = new ProcessBuilder("sslyze", host);
            processBuilder.redirectErrorStream(true);
            Process process = processBuilder.start();

            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));

            String line;
            while ((line = reader.readLine()) != null) {
                Logger.log("SSLyze output line: " + line);
                writer.write(line);
                writer.newLine();
                output.append(line).append("\n"); // Zapisz surowy output
            }
            reader.close();
            writer.close();

            int exitCode = process.waitFor();
            if (exitCode != 0) {
                output.append("SSLyze exited with error code: ").append(exitCode).append("\n");
                Logger.log("SSLyze exited with error code: " + exitCode);
            }
        } catch (Exception e) {
            output.append("Error running SSLyze: ").append(e.getMessage()).append("\n");
            Logger.log("Error running SSLyze: " + e.getMessage());
            e.printStackTrace();
        }

        rawScanResults.put(host, output.toString()); // Przechowywanie surowego wyniku skanu

        String comparisonResult = compareCipherSuites(outputFile);
        scanOutput = comparisonResult; // Zapisz wynik do pola scanOutput, usuwając surowy output

        Logger.log("cipherSuiteNames: " + cipherSuiteNames);
        Logger.log("cipherSuiteDetails : " + cipherSuiteDetails);
        Logger.log("scanOutput: " + scanOutput);
        Logger.log("rawScanResults: " + rawScanResults);

        saveScanResults(); // Dodane, aby zapisać wyniki po skanie

        return comparisonResult;
    }

    
    public static void clearCipherSuites() {
        cipherSuiteNames = new HashSet<>();
        cipherSuiteDetails = new HashMap<>();
        scanOutput = ""; // Wyczyszczenie wyników skanowania
        lastScannedHost = ""; // Wyczyszczenie ostatnio skanowanego hosta
        rawScanResults.clear(); // Wyczyszczenie surowych wyników skanowania
        saveScanResults(); // Zapisanie zmian

        Logger.log("Cleared all cipher suites.");
    }

    private static String compareCipherSuites(File outputFile) {
        StringBuilder result = new StringBuilder();
        Set<String> seenCipherSuites = new HashSet<>(); // Zestaw do przechowywania unikalnych cipherów
        try {
            BufferedReader reader = new BufferedReader(new FileReader(outputFile));
            String line;
            while ((line = reader.readLine()) != null) {
                String trimmedLine = line.trim();
                for (String cipherSuiteName : cipherSuiteNames) {
                    if (trimmedLine.contains(cipherSuiteName) && seenCipherSuites.add(cipherSuiteName)) {
                        result.append(cipherSuiteName).append(": ").append(cipherSuiteDetails.get(cipherSuiteName)).append("\n");
                        Logger.log("Matched cipher suite: " + cipherSuiteName);
                    }
                }
            }
            reader.close();
        } catch (IOException e) {
            result.append("Error reading SSLyze output file: ").append(e.getMessage()).append("\n");
            Logger.log("Error reading SSLyze output file: " + e.getMessage());
            e.printStackTrace();
        }
        Logger.log("compareCipherSuites result: " + result.toString());
        return result.toString();
    }


    public static Map<String, Integer> parseCipherSuites(String output) {
        Map<String, Integer> cipherSuitesCount = new HashMap<>();
        cipherSuitesCount.put("insecure", 0);
        cipherSuitesCount.put("weak", 0);
        cipherSuitesCount.put("secure", 0);
        cipherSuitesCount.put("recommended", 0);

        if (output != null) { // Dodaj to sprawdzenie, aby upewnić się, że output nie jest nullem
            String[] lines = output.split("\n");
            for (String line : lines) {
                if (line.endsWith(": insecure")) {
                    cipherSuitesCount.put("insecure", cipherSuitesCount.get("insecure") + 1);
                } else if (line.endsWith(": weak")) {
                    cipherSuitesCount.put("weak", cipherSuitesCount.get("weak") + 1);
                } else if (line.endsWith(": secure")) {
                    cipherSuitesCount.put("secure", cipherSuitesCount.get("secure") + 1);
                } else if (line.endsWith(": recommended")) {
                    cipherSuitesCount.put("recommended", cipherSuitesCount.get("recommended") + 1);
                }
            }
        }

        Logger.log("[SSLyzeSCAN]Parsed cipher suites: " + cipherSuitesCount);
        return cipherSuitesCount;
    }


    public static void runAndProcessSSLyzeScan(String host, VulnerabilityManager vulnerabilityManager) {
    	JOptionPane.showMessageDialog(null, "Scan for host " + host + " started!", "Information", JOptionPane.INFORMATION_MESSAGE);
        Map<String, String> cipherSuites = CipherSuiteInfo.fetchCipherSuites();
        if (cipherSuites != null && !cipherSuites.isEmpty()) {
            setCipherSuites(cipherSuites.keySet(), cipherSuites);
        } else {
            Logger.log("Failed to fetch cipher suites from API.");
            return;
        }

        Callable<String> task = () -> runSSLyzeScan(host);
        Consumer<String> onSuccess = scanOutput -> {
            Map<String, Integer> cipherSuitesCount = parseCipherSuites(scanOutput);
            vulnerabilityManager.updateCipherSuitesCount(cipherSuitesCount);
            addVulnerabilityIfNeeded(host, scanOutput, vulnerabilityManager);
            saveScanResults();
            Logger.log("SSLyze scan completed for host: " + host);
            vulnerabilityManager.getUIComponents().updateScanResultsList();
            JOptionPane.showMessageDialog(null, "Scan for host " + host + " finished!", "Information", JOptionPane.INFORMATION_MESSAGE);
        };
        Consumer<Exception> onError = ex -> Logger.log("Error occurred during SSLyze scan: " + ex.getMessage());

        new Worker<>(task, onSuccess, onError).execute();
    }


    private static void addVulnerabilityIfNeeded(String host, String scanOutput, VulnerabilityManager vulnerabilityManager) {
        boolean hasWeakOrInsecure = scanOutput.contains(": weak") || scanOutput.contains(": insecure");
        if (hasWeakOrInsecure) {
            try {
                SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z", Locale.ENGLISH);
                String discoveryTime = sdf.format(new Date());

                URL url = new URL("https://" + host);

                VulnerabilityStats newVulnerability = new VulnerabilityStats(
                        "TLS/SSL configuration weakness",
                        "Low",
                        url,
                        discoveryTime,
                        "",
                        "",
                        false
                );

                vulnerabilityManager.addVulnerability(newVulnerability);
                Logger.log("Added new vulnerability for host: " + host);
            } catch (Exception e) {
                callbacks.printError("Error adding vulnerability: " + e.getMessage());
                e.printStackTrace();
            }
        }
    }
}
